<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  
  <link href="http://feelerice.github.io/atom.xml" rel="self"/>
  
  <link href="http://feelerice.github.io/"/>
  <updated>2021-10-05T09:01:12.654Z</updated>
  <id>http://feelerice.github.io/</id>
  
  <author>
    <name>feelerice</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Synchronized锁升级</title>
    <link href="http://feelerice.github.io/2021/10/05/Synchronized%E9%94%81%E5%8D%87%E7%BA%A7/"/>
    <id>http://feelerice.github.io/2021/10/05/Synchronized%E9%94%81%E5%8D%87%E7%BA%A7/</id>
    <published>2021-10-05T01:18:54.000Z</published>
    <updated>2021-10-05T09:01:12.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Synchronized锁升级"><a href="#Synchronized锁升级" class="headerlink" title="Synchronized锁升级"></a>Synchronized锁升级</h1><h2 id="Synchronized的原理"><a href="#Synchronized的原理" class="headerlink" title="Synchronized的原理"></a>Synchronized的原理</h2><p>Sychronized是JVM虚拟机自带的可以实现线程安全机制的关键字。其工作原理如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (test.class)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这是上面代码的字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> ldc #<span class="number">14</span> &lt;com/lp/Test/test&gt;</span><br><span class="line"> <span class="number">2</span> dup</span><br><span class="line"> <span class="number">3</span> astore_1</span><br><span class="line"> <span class="number">4</span> monitorenter</span><br><span class="line"> <span class="number">5</span> aload_0</span><br><span class="line"> <span class="number">6</span> dup</span><br><span class="line"> <span class="number">7</span> getfield #<span class="number">2</span> &lt;com/lp/Test/test.i&gt;</span><br><span class="line"><span class="number">10</span> iconst_1</span><br><span class="line"><span class="number">11</span> iadd</span><br><span class="line"><span class="number">12</span> putfield #<span class="number">2</span> &lt;com/lp/Test/test.i&gt;</span><br><span class="line"><span class="number">15</span> aload_1</span><br><span class="line"><span class="number">16</span> monitorexit</span><br><span class="line"><span class="number">17</span> goto <span class="number">25</span> (+<span class="number">8</span>)</span><br><span class="line"><span class="number">20</span> astore_2</span><br><span class="line"><span class="number">21</span> aload_1</span><br><span class="line"><span class="number">22</span> monitorexit</span><br><span class="line"><span class="number">23</span> aload_2</span><br><span class="line"><span class="number">24</span> athrow</span><br><span class="line"><span class="number">25</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>我们可以看到在字节码指令中有monitorenter和monitorexit两个指令，这两个指令就是加锁指令。虚拟机在执行代码到同步代码块的时候需要先调用monitorenter指令来获取锁，在出同步代码块的时候又调用monitorexit指令释放锁。由于为了防止在代码执行的过程中出现异常而没有执行完同步代码块而导致没有释放锁，在字节码层面monitorenter有两个，其中一个是正常执行完成同步代码块而释放锁，另一个则是在同步代码中出现了异常依旧能够方式锁。</p><h2 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h2><p>在Java的对象内存分布上我们就说过，Java对象分为三个部分：对象头、实例数据、对齐填充。其中对象头又分为：MarkWord和类型指针。</p><p>MarkWord是一个对象能够成为锁的关键，其构成如下：</p><table height="50" width="300" border="1">    <tr align="center">        <th colspan="5">Mark Word (32 bit)</th>        <th>State</th>    </tr>    <tr align="center">        <td colspan="2">hashcode:25 </td>        <td>age:4</td>        <td> biased_lock:0 </td>        <td>01</td>        <td>Normal</td>    </tr>    <tr align="center">        <td> thread:23</td>        <td> epoch:2</td>        <td>age:4</td>        <td> biased_lock:0 </td>        <td>01</td>        <td>Biased</td>    </tr>    <tr align="center">        <td colspan="4">ptr_to_lock_record:30</td>        <td>00</td>        <td>Lightweight Locked</td>    </tr>    <tr align="center">        <td colspan="4">ptr_to_heavyweight_monitor:30</td>        <td>10</td>        <td> Heavyweight Locked </td>    </tr>    <tr align="center">        <td colspan="4"></td>        <td>11</td>        <td> Marked for GC </td>    </tr></table><table height="50" width="300" border="1">    <tr align="center">        <th colspan="6">Mark Word (64 bit)</th>        <th>State</th>    </tr>    <tr align="center">        <td>unuserd:25 </td>        <td>hashcode:31 </td>        <td>unused:1</td>        <td>adge:4</td>        <td> biased_lock:0 </td>        <td>01</td>        <td>Normal</td>    </tr>    <tr align="center">        <td>thread:54 </td>        <td>epoch:2 </td>        <td>unused:1</td>        <td>adge:4</td>        <td> biased_lock:0 </td>        <td>01</td>        <td>Biased</td>    </tr>    <tr align="center">        <td colspan="5">ptr_to_lock_record:62</td>        <td>00</td>        <td>Lightweight Locked</td>    </tr>    <tr align="center">        <td colspan="5">ptr_to_heavyweight_monitor:62</td>        <td>10</td>        <td> Heavyweight Locked </td>    </tr>    <tr align="center">        <td colspan="5"></td>        <td>11</td>        <td> Marked for GC </td>    </tr></table><h2 id="Monitor原理"><a href="#Monitor原理" class="headerlink" title="Monitor原理"></a>Monitor原理</h2><p>由于每一个Java对象都存在MarkWord字段，所以每一个Java对象都可以关联一个Monitor对象。如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针。</p><p>其结构如下：</p><p>​    <img src="/2021/10/05/Synchronized%E9%94%81%E5%8D%87%E7%BA%A7/Monitor.png"></p><ol><li>刚开始 Monitor 中 Owner 为 null </li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 个 Owner </li><li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKED </li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的 </li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程</li></ol><blockquote><p>注意： </p><ul><li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果 </li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul></blockquote><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>如果在一个对象作为锁，但他没有发生锁的竞争，那么这时JVM就会使用轻量级锁。没有发生竞争的情况有以下两种：</p><ul><li>单线程，只有一个线程执行，所以不会发生锁的竞争</li><li>多线程，虽然多个线程共用一把锁，但是每一个线程的执行时间是错开的，刚好不发生锁的争抢</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thread01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">        <span class="comment">// 线程1，执行的同步方法</span></span><br><span class="line">        thread02();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thread02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">        <span class="comment">// 线程2，执行的同步方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建锁记录（Lock Recode）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</li><li>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存 入锁记录</li><li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</li></ul><p><img src="/2021/10/05/Synchronized%E9%94%81%E5%8D%87%E7%BA%A7/monitor1.png"></p><ul><li>如果 cas 失败，有两种情况 <ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 </li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ul></li></ul><p><img src="/2021/10/05/Synchronized%E9%94%81%E5%8D%87%E7%BA%A7/monitor2.png"></p><ul><li><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重 入计数减一</p></li><li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象 头 </p><ul><li>成功，则解锁成功 </li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有 竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thread01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">        <span class="comment">//同步代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当Thread01来为obj对象添加轻量级锁的时候，此时obj已经被Thread-0添加过轻量级锁了</li></ol><p><img src="/2021/10/05/Synchronized%E9%94%81%E5%8D%87%E7%BA%A7/monitor3.png"></p><ol start="2"><li>此时Thread-1加锁失败进入锁膨胀<ol><li>为Object申请Monitor对象，让Object指向重量级锁的地址</li><li>自己进入到EntrySet中进入blocking状态</li></ol></li></ol><p><img src="/2021/10/05/Synchronized%E9%94%81%E5%8D%87%E7%BA%A7/monitor4.png"></p><ol start="3"><li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁 流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ol><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 </li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会 高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li><li> Java 7 之后不能控制是否开启自旋功能</li></ul><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。 </p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><p>一个对象创建时： </p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0 </li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>- XX:BiasedLockingStartupDelay=0</code> 来禁用延迟</li><li> 如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实对于<code>Synchronized</code>的优化，就是尽可能的减少加锁的资源消耗。其中轻量级锁、重量级锁为JVM特有的而自旋锁和偏向锁则是可以在代码层面实现的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Synchronized锁升级&quot;&gt;&lt;a href=&quot;#Synchronized锁升级&quot; class=&quot;headerlink&quot; title=&quot;Synchronized锁升级&quot;&gt;&lt;/a&gt;Synchronized锁升级&lt;/h1&gt;&lt;h2 id=&quot;Synchronized的</summary>
      
    
    
    
    
    <category term="锁" scheme="http://feelerice.github.io/tags/%E9%94%81/"/>
    
    <category term="JVM" scheme="http://feelerice.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>五种IO模型</title>
    <link href="http://feelerice.github.io/2021/10/03/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://feelerice.github.io/2021/10/03/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-10-03T02:48:12.000Z</published>
    <updated>2021-10-03T07:08:08.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h1><h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h2><p>在操作系统中把内存空间分为用户态与内核态，其中内核态的内存空间是不允许用户态进行访问的，而内核态是可以随意访问任何地址的内存空间。</p><h2 id="缓存-IO"><a href="#缓存-IO" class="headerlink" title="缓存 IO"></a>缓存 IO</h2><p>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在Linux操作系统中，操作系统会将IO的数据缓存在文件系统的页缓存（Page cache）中。也就是说，用户读取数据，操作系统会将数据先写入到内核的缓冲区中，然后才会将数据从内核的缓冲区写到用户的内存空间。由于数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h2 id="Linux-IO模型"><a href="#Linux-IO模型" class="headerlink" title="Linux IO模型"></a>Linux IO模型</h2><p>这里我们只针对网络IO，即socket套接字。</p><h3 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h3><p>同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在Linux中，默认情况下所有的socket都是blocking的。在这个IO模型之中将会产生两次阻塞。</p><ol><li>第一次阻塞发生在等待socket连接的时候</li><li>第二次阻塞发生在读取数据的时候</li></ol><p>由于每一次的调用都将会造成阻塞，只有等到有连接进入或者是有数据已经准备就绪的时候我们才能进行接下来的操作。那么对于服务器来说，这是一个很大的浪费。</p><h3 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h3><p>同步非阻塞IO，那么每一次我们需要的时候就调用系统调用如果当前的可以进行连接或者是数据已经准备就绪的情况下，就给我们返回准备好的连接或者是准备好的socket。而没有准备好的话就给我们一个错误信息，让我们的系统不至于陷入阻塞状态。</p><h3 id="IO的多路复用"><a href="#IO的多路复用" class="headerlink" title="IO的多路复用"></a>IO的多路复用</h3><p>在同步非阻塞的情况下，我们每调用一次accept或者是read都需要发起一次系统调用询问内核连接准备好了吗或者是有数据准备就绪嘛。在数量较小的时候这倒没有什么缺点，但是对于服务器端，一旦数量大起来之后，对于系统调用而消耗的资源将会增长的十分迅速。这时我们有没有什么办法将我们需要的所有状态一次传到内核，让内核帮我们进行插叙呢？这就是IO的多路复用。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>第一种IO的多路复用，其使用一个fd_set的结构（C语言）来存储我们需要遍历的socket，当fd_set中保存的socket具有读/写事件的时候内核就会返回对应的socket让系统进行操作。由于fd_set最多只能存放1024个socket文件描述符fd，所以select只能查询1024个socket的事件。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>由于select只能存放1024个socket文件描述符fd。对select进行改进之后就是poll了。在poll中相对于select而言只是基于链表实现fd_set结构。可以存储更多的文件描述符fd。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>虽然每一次都让内核来帮我们遍历socket，看有没有事件准备就绪，虽然相比于BIO、NIO而言效率提升了很多，但是在在数量很大的情况下O（n）的时间复杂度依旧是一个很大的开销，那么有没有什么办法可以降低时间复杂度呢？那就是为每一个socket注册一个回调函数，当事件准备就绪之后自动调用回调函数。并且数据也不再先拷贝到内核区域后在拷贝回用户态的内存区域了。这样一来效率就大幅度提升了。</p><h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p>首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>我们当前进程注册一个异步IO事件（使用signal注册一个信号<br>SIGIO的处理函数），然后当前进程可以正常处理自己的事情，当异步事件发生后当前进<br>程会收到一个SIGIO信号从而执行绑定的处理函数去处理这个异步事件。其实所有的信号<br>都是软件实现的一种中断机制，所以异步IO其实就是利用了信号这种软件中断机制来工作<br>的,工作流程如下：</p><ol><li>设置设备文件fd具有接收IO的功能</li><li>设置异步IO事件的接收进程</li><li>注册信号处理函数（也就是绑定）</li></ol><p>目前Linux上并没有实现异步IO，而Windows操作系统上具有实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;五种IO模型&quot;&gt;&lt;a href=&quot;#五种IO模型&quot; class=&quot;headerlink&quot; title=&quot;五种IO模型&quot;&gt;&lt;/a&gt;五种IO模型&lt;/h1&gt;&lt;h2 id=&quot;用户态与内核态&quot;&gt;&lt;a href=&quot;#用户态与内核态&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="IO" scheme="http://feelerice.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Executors线程池</title>
    <link href="http://feelerice.github.io/2021/10/01/Executors%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://feelerice.github.io/2021/10/01/Executors%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-10-01T01:07:53.000Z</published>
    <updated>2021-10-03T02:47:48.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Executors线程池"><a href="#Executors线程池" class="headerlink" title="Executors线程池"></a>Executors线程池</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在我们多线程的编程中，每次有任务来的时候，我们一般情况下都是直接新建一个线程来执行传过来的任务，等待任务执行完成之后就任由线程消亡。但是这样的开发其实有一个非常大的缺点，那就是线程的创建和计算机内核有很大的关系，每一次线程创建都要消耗大量的系统资源，如果只是少量创建的话，拿到也还可以接收，但是在实际的开发中任务的传递却是十分平常的。那么我们有没有一种方法可以把执行完任务的线程进入wait状态保存起来，不让其消亡。等到有新的任务来的时候如果我们还有在wait状态的线程就不需要新建线程，而是可以选择唤醒在wait状态的线程让他去执行任务，这样一来我们就节约了创建线程的资源浪费了。而且，如果直接使用新建线程来执行任务还会在任务量巨大的时候操作系统的卡顿，因为无法控制线程的创建数量。而我们的JUC高并发包中提供了ThreadPoolExecutor类来实现我们的需求。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ctl：高位表示法，最高三位表示当前线程池的状态，剩下的29位表示当前线程池的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// 011</span></span><br><span class="line"><span class="comment">// RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非核心线程的存活事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">//核心线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">//最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;    </span><br><span class="line"><span class="comment">//线程拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">//默认拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"><span class="comment">//阻塞队列，当前线程池的全部线程都子啊执行人物的时候，在添加任务就会进入阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户需要提供五个参数，提供默认线程Factory和defaultHandler拒绝策略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用户需要提供六个参数，提供的默认拒绝策略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用户提供六个参数，默认提供线程Factory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用户提供构造器所需的所有需要的七个参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> :</span><br><span class="line">    AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码看出，构建一个线程池需要提供七个参数，分别是：</p><ul><li>corePoolSize：核心线程数，表示不会被消亡的线程数</li><li>maximumPoolSize：线程池锁维护的最大的线程数，超出核心线程数的线程会在一段时间后消亡</li><li>keepAliveTime：时间，表示非核心线程在多长时间后消亡</li><li>unit：时间单位，keepAliveTime的时间单位</li><li>workQueue：阻塞工作队列，在线程池可用的所有线程都在运行时，添加进来的任务将会被存入workQueue</li><li>threadFactory：线程工程Factory，用于生产线程的工厂类</li><li>handler：拒绝策略，当线程池中的线程数为最大数量，任务队列也满的时候，线程池将会根据用户选择的拒绝策略来选择如何处理再加进来的任务。</li></ul><h2 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h2><p>对于构造线程池所用到的参数，workQueue和handler有以下几个选择：</p><p>workQueue：</p><ul><li>ArrayBlockingQueue</li><li>SychronousQueue</li><li>DelayQueue</li><li>LinkedBlockingQueue</li><li>PriorityBlockingQueue</li></ul><p>handler：</p><ul><li>AbortPolicy：直接抛出异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                         <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                         e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DiscardOldestPolicy：丢弃最早放入队列的任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        e.getQueue().poll();</span><br><span class="line">        e.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CallerRunsPolicy：本线程执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DiscardPolicy：什么都不做</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h2><p>在创建线程池的时候，我们不需要每次都去直接创建ThreadPoolExecutor，而是可以选择Executors中的静态方法来创建线程池，由于Executors中的静态方法以及为我们提供了集中功能的参数，所有我们只需要提供所需要的线程数就可以了。</p><ul><li>newCachedThreadPool</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到newCachedThreadPool为我们提供的是一个没有核心线程的线程池，但与之相对的时有Integer.MAX_VALUE（2^29 - 1）的线程数。并且队列使用的时SynchronousQueue</p><ul><li>newFixedThreadPool</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码我们可以看出，newFixedThreadPool返回了一个只有核心线程的线程池</p><ul><li>newScheduledThreadPool</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newScheduledThreadPool方法返回了一个ScheduledThreadPoolExecutor的实例</p><ul><li>newSingleThreadExecutor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newSingleThreadExecutor方法返回了一个FinalizableDelegatedExecutorService的实例，FinalizableDelegatedExecutorService是ThreadPoolExecutor的包装类，目的是为了让创建单例线程池的人不能调用ThreadPoolExecutor的方法</p><h2 id="线程池分析"><a href="#线程池分析" class="headerlink" title="线程池分析"></a>线程池分析</h2><p>线程池既然要重复利用线程的循环的完成任务，那么线程池是怎么做到的呢？我们从线程池的入口方法execute方法来看：</p><h3 id="execute方法："><a href="#execute方法：" class="headerlink" title="execute方法："></a>execute方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 如果当前活动线程数小于corePoolSize，则新建一个核心线程放入线程池中，并把任务添加到该线程中</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前活动线程数大于等于corePoolSize，则尝试将任务放入缓存队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果添加队列失败，则尝试创建非核心线程执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 创建非核心线程失败，执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWorker方法："><a href="#addWorker方法：" class="headerlink" title="addWorker方法："></a>addWorker方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// 判断能否进行添加</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 能否创建指定类型的线程（core true表示核心线程；false表示非核心线程）</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 增加工作线程数，成功就跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 重新检查线程池状态</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// // 新建一个Worker，将要执行的任务作为参数传进去</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 添加worker成功之后启动worker</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//worker绑定的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">// 创建Worker的任务，可能为null</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    </span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码我们可以看出，当我们在addWorker中启动线程的时候，线程调用了runWorker方法，并将自己传了过去。下面我们来看runWorker方法。</p><h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); </span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将runWorker方法进行简化，去除对线程池的判断的细节实现可得出以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 执行任务的前调方法</span></span><br><span class="line">             beforeExecute(wt, task);</span><br><span class="line">             Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 执行任务</span></span><br><span class="line">                 task.run();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                 thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                 thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                 thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">// 执行任务的后调方法</span></span><br><span class="line">                 afterExecute(task, thrown);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             task = <span class="keyword">null</span>;</span><br><span class="line">             w.completedTasks++;</span><br><span class="line">             w.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个runWorker方法中最重要的代码其实是while循环语句，在while循环中runWorker尝试从getTask来保证自己一直执行下去。</p><h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">//检查现在线程池的状态</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 如果需要进行超时控制，且上次从缓存队列中获取任务时发生了超时，</span></span><br><span class="line">            <span class="comment">// 那么尝试将workerCount减1,即当前活动线程数减1，</span></span><br><span class="line">            <span class="comment">// 如果减1成功，则返回null，这就意味着runWorker()方法中的while循环会被退出，</span></span><br><span class="line">            <span class="comment">// 其对应的线程就要销毁了，也就是线程池中少了一个线程了</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            workQueue.take();</span><br><span class="line">            <span class="comment">// 注意workQueue中的poll()方法与take()方法的区别</span></span><br><span class="line">            <span class="comment">// poll方式取任务的特点是从缓存队列中取任务,最长等待keepAliveTime的时长，取不到返回null</span></span><br><span class="line">            <span class="comment">// take方式取任务的特点是从缓存队列中取任务，若队列为空,则进入阻塞状态，直到能取出对象为止</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以getTask方法的作用：</p><ol><li><p>如果当前活动线程数大于核心线程数，当去缓存队列中取任务的时候，如果缓存队列中没任务了，则等待keepAliveTime的时长，此时还没任务就返回null，这就意味着runWorker()方法中的while循环会被退出，其对应的线程就要销毁了，也就是线程池中少了一个线程了。因此只要线程池中的线程数大于核心线程数就会这样一个一个地销毁这些多余的线程。</p></li><li><p>如果当前活动线程数小于等于核心线程数，同样也是去缓存队列中取任务，但当缓存队列中没任务了，就会进入阻塞状态，直到能取出任务为止，因此这个线程是处于阻塞状态的，并不会因为缓存队列中没有任务了而被销毁。这样就保证了线程池有N个线程是活的，可以随时处理任务，从而达到重复利用的目的。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Executors线程池&quot;&gt;&lt;a href=&quot;#Executors线程池&quot; class=&quot;headerlink&quot; title=&quot;Executors线程池&quot;&gt;&lt;/a&gt;Executors线程池&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="JUC" scheme="http://feelerice.github.io/tags/JUC/"/>
    
    <category term="线程池" scheme="http://feelerice.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>AQS详解</title>
    <link href="http://feelerice.github.io/2021/09/30/AQS%E8%AF%A6%E8%A7%A3/"/>
    <id>http://feelerice.github.io/2021/09/30/AQS%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-09-30T01:51:16.000Z</published>
    <updated>2021-09-30T02:48:44.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AQS详解"><a href="#AQS详解" class="headerlink" title="AQS详解"></a>AQS详解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java的JUC（Java.util.Concurrent）包是一个十分强大的并发工具包，其实现原理是基于volatile和Unsafe类在代码层面是实现的锁。JUC并发包给我们提供了许多优秀的锁工具包，但是对于每一种锁的实现都具有许多相同的代码我们完全可以将其提取出来做一个公共父类，还有就是对于代码层面的锁，如果我们采用自旋锁的方式在线程数多的情况下就会造成资源的浪费。所以在JUC包中提取出来了一个其他所有类的父类AbstractQueueSychronizer，他具有管理其他没有获取到锁的线程和进行CAS操作相关代码抽取的工作。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>由于AbstractQueueSychronizer类是一个抽象类，他提供了几个方法，如果子类没有实现而是调用AQS的方法将会抛出异常，这些方法分别是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我将从AQS最为经典的子类ConcurrentLock进行解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AQSTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUM = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Num</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        CountDownLatch downLatch = <span class="keyword">new</span> CountDownLatch(THREAD_NUM);</span><br><span class="line">        Num num = <span class="keyword">new</span> Num();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.lock();</span><br><span class="line">                        num.increase();</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                downLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        downLatch.await();</span><br><span class="line">        System.out.println(num.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的一个方法是一个非常今典的实现，可是我们需要想一下如果线程发生争抢之后，锁竞争失败的线程会怎么样，会一直在某个地方方式自选还是进入wait状态，如果时进入wait状态那么什么时候谁会将其唤醒。</p><p>我们看一下ReentanctLock的源代码，在此之前，我们需要知道ReentranctLock的一些成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure><p>Sync是一个实现了AbstractQueueSychronizer的类，它实现了release方法，但是也提供了一个lock的抽象方法供其子类FairSync（公平锁）和NonfairSync（非公平锁）来具体实现。</p><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>对于我们调用lock方法之后，我们先以其默认实现NonfairSync来进行解说，方法会进入到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，线程先会调用compareAndSetState()方法尝试加锁，如果成功就调用setExclusiveOwnerThread()方法设置独占锁；如果失败那么就会调用acquire（1）方法再次尝试加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在acquire方法中，他先进行tryAcquire（arg）再一次进行枪锁最终他会进入到NonfairSync中重写的方法nonfairTryAcquire中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">//冲入锁</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次方法中，他会根据当前的状态进程获取锁或者是进行重入锁的操作，如果都进行失败了，那么它将会调用addWaiter(Node.EXCLUSIVE)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将会对当前线程进行一个封装（为了放入一个阻塞队列中），最后进入acquireQueued方法中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在acquireQueued方法中，他会再一次进行加锁操作，如果都失败了，那么这个线程就会在parkAndCheckInterrupt()方法中进入wait状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过一系列的操作之后，没有争抢到锁的线程会进入wait状态并且被封装在Node中加入AQS锁维护的一个阻塞队列中</p><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><p>那么当我们索取到锁的线程调用了unlock方法之后，AQS又是如何唤醒进入wait状态的线程呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AQS的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用unlock方法之后，最终会进入到release方法中，并调用tryRelease方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在tryRelease方法中会尝试解锁，并且判断是不是多次调用了lock操作，如果是，那么没调用一次unlock方法对volatile变量进行减一操作直至减到0才算解锁成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在tryRelease方法中解锁成功，那么最终将会进入unparkSuccessor方法中尝试唤醒线程LockSupport.unpark(s.thread);。</p><h2 id="公平锁与非公平锁的区别"><a href="#公平锁与非公平锁的区别" class="headerlink" title="公平锁与非公平锁的区别"></a>公平锁与非公平锁的区别</h2><p>通过我们上述的分析后知道了，AQS就是JUC包中几乎所有锁的一个模板，不同的锁只需要按照自己的需要继承AQS后重新相关操作就可以了，那么公平锁与非公平锁有什么区别呢？显然就是加锁的时候不一致。</p><p>在公平锁中，由于AQS中维护了一个队列，那么加锁的时候判断当前要加锁的线程是不是队列中第一个线程，如果是就可以继续加锁，如果不是那么就不许加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断队列中的线程</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AQS其实就是一个对JUC包中所有锁的公共代码的提取，以提高代码的复用性。同时他也维护了一个队列用于保证没有获取锁的线程可以进入到wai状态不至于陷入无限自选的状态，并且可以在获取锁的线程释放所得时候进行唤醒线程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AQS详解&quot;&gt;&lt;a href=&quot;#AQS详解&quot; class=&quot;headerlink&quot; title=&quot;AQS详解&quot;&gt;&lt;/a&gt;AQS详解&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概</summary>
      
    
    
    
    
    <category term="java" scheme="http://feelerice.github.io/tags/java/"/>
    
    <category term="多线程" scheme="http://feelerice.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="JUC" scheme="http://feelerice.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>手写LRU算法</title>
    <link href="http://feelerice.github.io/2021/09/29/%E6%89%8B%E5%86%99LRU%E7%AE%97%E6%B3%95/"/>
    <id>http://feelerice.github.io/2021/09/29/%E6%89%8B%E5%86%99LRU%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-29T13:26:18.000Z</published>
    <updated>2021-09-30T01:50:46.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手写LRU算法"><a href="#手写LRU算法" class="headerlink" title="手写LRU算法"></a>手写LRU算法</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>LRU算法的全称为Least Recently Used（最近最少使用），其作用为创建一个LRU容器，向容器中添加元素，如果超出最大限度的话，那么久删除距离当前之间最长没有使用的元素，以存下要放下的元素。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用链表实现，每一次使用put或者get操作，都将当前元素放在链表头。</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>使用ListedHashMap实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU1</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    LRU1(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>使用HashMap + 双向链表实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer key;</span><br><span class="line">        <span class="keyword">private</span> Integer value;</span><br><span class="line">        <span class="keyword">private</span> Node pre;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        Node()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Node(Integer Key,Integer value)&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.key = Key;</span><br><span class="line">            <span class="keyword">this</span>.pre = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node head;</span><br><span class="line">        <span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">        LinkedNode()&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">new</span> Node();</span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="keyword">new</span> Node();</span><br><span class="line">            <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.tail;</span><br><span class="line">            <span class="keyword">this</span>.tail.pre = <span class="keyword">this</span>.head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            node.pre = head;</span><br><span class="line">            head.next.pre = node;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">            node.pre = <span class="keyword">null</span>;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedNode link;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Node&gt; map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRU2</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.link = <span class="keyword">new</span> LinkedNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        link.removeNode(node);</span><br><span class="line">        link.addHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            link.removeNode(node);</span><br><span class="line">            link.addHead(node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.size() == capacity)&#123;</span><br><span class="line">            Node node = link.tail.pre;</span><br><span class="line">            link.removeNode(node);</span><br><span class="line">            map.remove(node.key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        link.addHead(node);</span><br><span class="line">        map.put(key,node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>纯链表实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">private</span> Node pre;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        Node()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> key, <span class="keyword">int</span> value)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.pre = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">linkedNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node head;</span><br><span class="line">        <span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">        linkedNode()&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">new</span> Node();</span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="keyword">new</span> Node();</span><br><span class="line">            head.next = tail;</span><br><span class="line">            tail.pre = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">            Node con = head;</span><br><span class="line">            <span class="keyword">while</span> (con.next != tail)&#123;</span><br><span class="line">                <span class="keyword">if</span> (con.next.key == key)</span><br><span class="line">                    <span class="keyword">return</span> con.next;</span><br><span class="line">                con = con.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">            node.pre = <span class="keyword">null</span>;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            node.pre = head;</span><br><span class="line">            head.next.pre = node;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> linkedNode list;</span><br><span class="line"></span><br><span class="line">    LRU3(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> linkedNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        Node node = list.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        list.remove(node);</span><br><span class="line">        list.addHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((node = (list.get(key))) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            list.remove(node);</span><br><span class="line">            list.addHead(node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (capacity == size)&#123;</span><br><span class="line">            node = list.tail.pre;</span><br><span class="line">            node.key = key;</span><br><span class="line">            node.value = value;</span><br><span class="line">            list.remove(node);</span><br><span class="line">            list.addHead(node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = <span class="keyword">new</span> Node(key,value);</span><br><span class="line">        list.addHead(node);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;手写LRU算法&quot;&gt;&lt;a href=&quot;#手写LRU算法&quot; class=&quot;headerlink&quot; title=&quot;手写LRU算法&quot;&gt;&lt;/a&gt;手写LRU算法&lt;/h1&gt;&lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简</summary>
      
    
    
    
    
    <category term="redis" scheme="http://feelerice.github.io/tags/redis/"/>
    
    <category term="LRU" scheme="http://feelerice.github.io/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="http://feelerice.github.io/2021/09/28/TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://feelerice.github.io/2021/09/28/TCP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-09-28T05:46:01.000Z</published>
    <updated>2021-09-28T06:58:48.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h2><p>（1）序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p><p>（2）确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p><p>（3）标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：</p><blockquote><p>URG：紧急指针（urgent pointer）有效。<br>ACK：确认序号有效。<br>PSH：接收方应该尽快将这个报文交给应用层。<br>RST：重置连接。<br>SYN：发起一个新连接。<br>FIN：释放一个连接。</p></blockquote><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>所谓的三次握手即TCP连接的建立。（默认为客户端发起请求，服务端接收请求。其中服务端必须处于LISTEN）</p><ol><li> 客户端发起一个TCP报文给服务端，其序号=x，标志位=SYN。进入SYN-SENT</li></ol><blockquote><p>序号Seq = x（一般为1）</p><p>确认号Ack无</p><p>标志位Flags = SYN</p></blockquote><ol start="2"><li><p>服务端接收到客户端的请求之后，结束监听（LISTEN）状态，并向客户端返回一个TCP报文，表示服务端接收到连接请求，并同意创建连接。进入SYN-RCVD</p><blockquote><p>序号 Seq = y（自己创建的）<br>确认好Ack = x+ 1 （这里的x是客户端发送过来的Seq）<br>标志位Flags = SYN &amp; ACK，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”</p></blockquote></li><li><p>客户端接收到来自服务端的报文之后向服务端在发送一个TCP报文，并结束SYN-SENT，进入ESTABLISH</p><blockquote><p>序号 Seq = x + 1（第一次发送的）<br>确认号Ack = y + 1（这里的y是服务端发来的）<br>标志位Flags = ACK</p></blockquote></li></ol><p>下面就是TCP协议的三次握手：</p><p><img src="/2021/09/28/TCP%E5%8D%8F%E8%AE%AE/handshak.png"></p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>所谓四次挥手，也就是客户端进行关闭TCP连接时和服务端进行的通话。</p><ol><li><p>客户端发送一个TCP报文给服务端表示自己要关闭TCP连接，自己进入FIN-WAIT1状态（表示客户端不在发送数据，但可以接受服务端发送的数据）</p><blockquote><p>序号Seq = u<br>确认号 Ack = 无<br>标志位Flags = FIN</p></blockquote></li><li><p>服务端接收到客户端发送的TCP报文，返回一个TCP报文表示自己收到关闭连接的请求，服务端进入CLOSE-WAIT状态</p><blockquote><p>序号Seq = v<br>确认好 Ack = u + 1<br>标志位Flags = ACK</p></blockquote></li><li><p>客户端收到到服务端的反馈报文进入FIN-WAIT2状态</p></li><li><p>服务端处理好所有的数据之后，在想客户端发送一个TCP报文表示自己准备关闭TCP连接</p><blockquote><p>序号Seq = w<br>确认号 Ack = u + 1<br>标志位Flags = FIN &amp; ACK</p></blockquote></li><li><p>客户端收到客户端发来的关闭报文之后，向服务端发送一个TCP报文，自己进入长达2MSL的时间TIME-WAIT状态</p><blockquote><p>序号Seq = u + 1<br>确认好Ack = w + 1<br>标志位Flags = ACK</p></blockquote></li><li><p>服务端收到客户端发送过来的请求之后，关闭TCP连接进入CLOSE状态</p></li><li><p>客户端在2MSL的时间里没收到任何TCP报文就自动关闭TCP连接</p></li></ol><p>其工作流程图如下：</p><p><img src="/2021/09/28/TCP%E5%8D%8F%E8%AE%AE/4wave.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP协议&quot;&gt;&lt;a href=&quot;#TCP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP协议&quot;&gt;&lt;/a&gt;TCP协议&lt;/h1&gt;&lt;h2 id=&quot;重要字段&quot;&gt;&lt;a href=&quot;#重要字段&quot; class=&quot;headerlink&quot; title=&quot;重要字段&quot;</summary>
      
    
    
    
    
    <category term="网络协议" scheme="http://feelerice.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="TCP" scheme="http://feelerice.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制</title>
    <link href="http://feelerice.github.io/2021/09/28/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://feelerice.github.io/2021/09/28/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2021-09-28T03:48:58.000Z</published>
    <updated>2021-10-04T08:20:08.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Class文件之中存在着各类信息，但最终都需要加载到虚拟机才能被使用。Java虚拟机把描述类的数据从Class文件加载到内存中，并且对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称之为虚拟机的类加载机制，其他语言不同，在Java语言中，类的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会增加一些类加载时的性能开销，但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态拓展的语言特性就是依赖运行期间动态加载和动态连接这个特点实现的。</p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，他的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。这七个阶段的发生顺序如下所示：</p><p><img src="/2021/09/28/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/loadClass.png"></p><p>在上图中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序进行按部就班地开始，而解析阶段则不一定了：他在某些特殊的情况下在初始化之后再开始，这是为了支持Java语言的运行时绑定数据特性。</p><p>对于加载这一阶段的，《Java虚拟机规范》中并没有进行强制的约束。但是对于初始化阶段《Java虚拟机规范》中则是严格规定了有且仅有六种情况必须立刻对类进行“初始化”：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令的时候，如果没有进行过初始化，则需要对其进行初始化。而可以生产这四条字节码指令的场景有：<ol><li>使用new关键字</li><li>读取一个类中的静态字段，被final修饰的除外</li><li>调用静态方法的时候</li></ol></li><li>使用java.lang.reflet包的方法进行反射调用的时候需要初始化</li><li>当初始化子类的时候，需要对父类进行初始化</li><li>当虚拟机启动的时候，需要对包含main方法的类进行初始化</li><li>JDK8之后，接口的默认方法实现类被初始化的时候</li><li>JDK7之后，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStaic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，需要对其进行初始化。</li></ol><p>除此之外所有引用类型的方式都不会触发初始化，成为被动引用。下面有几个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    System.out.println(SubClass.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序只会输出SuperClass和0。对于静态字段，只有直接定义这个字段的类才会被初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    SuperClass[] array = <span class="keyword">new</span> SuperClass[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序什么都不会输出，这是因为虚拟机自动为我们创建了一个继承于SuperClass的一维数组子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalStatic</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;FinalStatic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    System.out.println(FinalStatic.VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序只会输出10，这是因为value再转化为字节码文件之后，存放在了常量池中。所以对其调用不会触发类的初始化。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java虚拟机设计团队有意把类加载阶段中“通过一个类的全限定类名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便于让与应用程序自己觉得如何去进行获取所需的类。实现这个动作的代码被称之为类加载器（Class Loader）。</p><p>类加载器虽然只用于实现类的加载动作，但是他在Java程序中起到作用却远超类加载阶段。对于任意一个类，都必须由加载他的类加载器和这个类本身一起共同确定其在Java虚拟机中的唯一性，每一个加载器都拥有一个独立的类名称空间。</p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>在Java虚拟机的角度来看，只存在两种不同的类加载器：</p><ol><li>启动类加载器（Bootstrap Class Loader）由C++语言实现，是虚拟机的一部分</li><li>其他类加载器，由Java语言实现，独立于虚拟机外部，并且全部继承子抽象类java.lang.ClassLoader</li></ol><p>在JDK8之前，Java就一直保持着三层类加载器，双亲委派机制的类加载架构。对于Java的绝大多数程序员都护用到以下三个系统提供的类加载器来进行加载。</p><ol><li>启动类加载器（Bootstrap Class Loader）：加载\lib目录下的文件</li><li>拓展类加载器（Extension Class Loader）：加载\lib\ext目录中的文件</li><li>应用程序类加载器（Application Class Loader）：负责加载用户路径上的所有类库。</li></ol><p>下图为各种累加器之间的层次关系被称之为类加载器的“双亲委派模型（Parent Delegation Model）”.</p><p><img src="/2021/09/28/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/delegation.png"></p><p>注意双亲委派机制要求除了启动类加载器以外，其他类加载器都应该有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承关系来实现的，而是通过组合关系福来用负载假期的代码。</p><p>双亲委派机制的工作流程：如果一个类加载器收到了类加载请求，他首先不会自己尝试去加载这个类，而是所有的加载请求最终都应该传送到顶层启动类加载器中，只有父加载器无法完成加载请求时，子加载器还能尝试自己去完成加载。</p><h2 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h2><p>线程上下文类加载器</p><p>Tomcat类加载机制</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类加载机制&quot;&gt;&lt;a href=&quot;#类加载机制&quot; class=&quot;headerlink&quot; title=&quot;类加载机制&quot;&gt;&lt;/a&gt;类加载机制&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://feelerice.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁与事务</title>
    <link href="http://feelerice.github.io/2021/09/27/MySQL%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/"/>
    <id>http://feelerice.github.io/2021/09/27/MySQL%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-09-27T07:08:40.000Z</published>
    <updated>2021-10-04T08:20:20.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL锁与事务"><a href="#MySQL锁与事务" class="headerlink" title="MySQL锁与事务"></a>MySQL锁与事务</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。其具有以下四个特性</p><ul><li>原子性（Atomic）：事务包含的所有操作要不全部成功，要不全部失败。</li><li>一致性（Consistency）：是指数据库中的数据应满足完整性约束，确保数据库的状态转向另一个一致的状态，如：用户A和用户B一共2000元，那么无论AB怎么进行转账操作，最后他们的钱总和也一定要2000元</li><li>隔离性（Isolation）：多个事务并发执行的时候，不应该影响到其他事务</li><li>持久性（Durability）：在数据库发生故障的时候，已提交的事务应该永久的停留在数据库里面</li></ul><h2 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h2><ul><li>更新丢失：一个事物的更新覆盖了另一个事物的更新</li></ul><table><thead><tr><th align="center">取款事务</th><th align="center">存款事务</th></tr></thead><tbody><tr><td align="center">开始事务</td><td align="center">开始事务</td></tr><tr><td align="center">查询账户余额100元</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">查询转账余额100</td></tr><tr><td align="center"></td><td align="center">存入20元，余额为120元</td></tr><tr><td align="center"></td><td align="center">提交事务</td></tr><tr><td align="center">取出10元，余额改为90元</td><td align="center"></td></tr><tr><td align="center">回滚事务，余额恢复100元</td><td align="center">更新丢失</td></tr></tbody></table><ul><li>脏读：一个事务中读取到了另一个事务没有提交的数据。</li></ul><table><thead><tr><th align="center">事务1</th><th align="center">事务2</th></tr></thead><tbody><tr><td align="center">开始事务</td><td align="center">开始事务</td></tr><tr><td align="center"></td><td align="center">修改余额为100</td></tr><tr><td align="center">查询余额：100</td><td align="center">rollback</td></tr><tr><td align="center">更新余额：100+200=300</td><td align="center"></td></tr><tr><td align="center">提交事务</td><td align="center"></td></tr></tbody></table><ul><li>不可重复读：事务中两次读取的数据不一致（被其他事务修改过）</li></ul><table><thead><tr><th align="center">事务1</th><th align="center">事务2</th></tr></thead><tbody><tr><td align="center">开始事务</td><td align="center">开始事务</td></tr><tr><td align="center">查询余额：200</td><td align="center">更新余额：300元</td></tr><tr><td align="center"></td><td align="center">提交事务</td></tr><tr><td align="center">查询余额：300</td><td align="center"></td></tr></tbody></table><ul><li>幻读：事务第二次读取数据和第一次读取的数据条数不符合</li></ul><table><thead><tr><th align="center">事务1</th><th align="center">事务2</th></tr></thead><tbody><tr><td align="center">开始事务</td><td align="center">开始事务</td></tr><tr><td align="center">查询id为2数据：3条</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">插入一条id为2的数据</td></tr><tr><td align="center"></td><td align="center">提交事务</td></tr><tr><td align="center">更新id为2的数据：成功4条</td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center">事务隔离级别</th><th align="center">更新丢失</th><th align="center">脏读</th><th align="center">不可重读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMITED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITED</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h2 id="隔离性的实现"><a href="#隔离性的实现" class="headerlink" title="隔离性的实现"></a>隔离性的实现</h2><p>InnoDB数据库隔离性的实现是由MVCC（多版本并发控制来进行实现的），MVCC在InnoDB的实现主要是依靠undo log和read View来进行实现。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>当前读：读取的是当前最新的数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select ... for update;</span><br><span class="line">select ... lock in share mode;</span><br><span class="line">update ... ;</span><br><span class="line">insert ... ;</span><br><span class="line">delete ... ;</span><br></pre></td></tr></table></figure><ul><li>快照读：读取的是快照中的数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ... ;</span><br></pre></td></tr></table></figure><h3 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h3><p>在数据行中，InnoDB将数据分为两个部分：用户可见部分和不可见部分</p><ul><li>用户可见部分：也就是用户定义一张表的时候锁规定的数据列</li><li>用户不可见部分：有InnoDB数据库生成的列，其有三列分别为</li></ul><table><thead><tr><th align="center">列名</th><th align="center">长度</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">DB_ROLL_PTR</td><td align="center">7</td><td align="center">用于指向未被修改前的数据</td></tr><tr><td align="center">DB_ROW_ID</td><td align="center">6</td><td align="center">隐藏ID，在InnoDB中创建表如果没有主键也没有唯一行则会使用这个列当作隐藏主键用于创建聚簇索引</td></tr><tr><td align="center">DB_TRX_ID</td><td align="center">6</td><td align="center">事务ID，用于记录当前记录是由哪一个事务进行修改的。</td></tr></tbody></table><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>在InnoDB数据库中用户每对数据进行修改一次，就会将修改之前的数据存放在InnoDB的undo log中。</p><h3 id="read-View"><a href="#read-View" class="headerlink" title="read View"></a>read View</h3><p>读视图，在RR与RC隔离级别下。生成read View的时机不同：</p><ul><li>RC：每一次快照读都会生成一个read View</li><li>RR：只会生成第一次的快照读</li></ul><p>read View为每一个事务都有各自一份的数据，他的组成有以下几个部分</p><table><thead><tr><th align="center">名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">trx_list</td><td align="center">记录生成read View时刻的事务有哪些</td></tr><tr><td align="center">up_limit_ID</td><td align="center">当前活跃事务的最小值</td></tr><tr><td align="center">low_limit_ID</td><td align="center">未生成事务的最小ID</td></tr></tbody></table><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>MVCC也叫多版本并发控制，他的实现也就是通过上面的几个知识一起实现的。</p><h2 id="持久性的实现"><a href="#持久性的实现" class="headerlink" title="持久性的实现"></a>持久性的实现</h2><h3 id="IO知识"><a href="#IO知识" class="headerlink" title="IO知识"></a>IO知识</h3><p>在计算机上的IO读取分为</p><ul><li>随机IO：数据的存储并不是连续的，而是在整个磁盘上存储，读取/写入操作的时间大都浪费在寻址上。</li><li>顺序IO：数据的存储是连续的地址，不需要花费时间在寻址上</li></ul><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>redo log分为两个部分redo log buffer和redo log file。一个是存放在内存中的缓冲区而另外一个则是存放在磁盘上的持久化文件。</p><h3 id="mini-transaction"><a href="#mini-transaction" class="headerlink" title="mini-transaction"></a>mini-transaction</h3><p>Redo的实现实则跟mini-transaction紧密相关，mini-transaction是一种InnoDB内部使用的机制，通过mini-transaction来<strong>保证并发事务操作下以及数据库异常时数据页中数据的一致性</strong>，但它不属于事务。</p><p><strong>为了使得mini-transaction保证数据页数据的一致性，mini-transaction必须遵循以下三种协议</strong>：</p><ul><li>The FIX Rules</li><li>Write-Ahead Log</li><li>Force-log-at-commit</li></ul><p><strong>The FIX Rules</strong></p><p>修改一个数据页时需要获得该页的x-latch(排他锁)，获取一个数据页时需要该页的s-latch(读锁或者称为共享锁) 或者是 x-latch，持有该页的锁直到修改或访问该页的操作完成。</p><p><strong>Write-Ahead Log</strong></p><p>在前面阐述中就提到了Write-Ahead Log(预先写日志)。在持久化一个数据页之前，必须先将内存中相应的日志页持久化。每个页都有一个LSN(log sequence number)，代表日志序列号，（LSN占用8字节，单调递增), 当一个数据页需要写入到持久化设备之前，要求内存中小于该页LSN的日志先写入持久化设备</p><p>那为什么必须要先写日志呢？可不可以不写日志，直接将数据写入磁盘？原则上是可以的，只不过会产生一些问题，数据修改会产生随机IO，但日志是顺序IO，append方式顺序写，是一种串行的方式，这样才能充分利用磁盘的性能。</p><p><strong>Force-log-at-commit</strong></p><p>这一点也就是前文提到的如何保证事务的持久性的内容，这里再次总结一下，与上面的内容相呼应。在一个事务中可以修改多个页，Write-Ahead Log 可以保证单个数据页的一致性，但是无法保证事务的持久性，Force-log-at-commit 要求当一个事务提交时，其产生所有的mini-transaction 日志必须刷新到磁盘中，若日志刷新完成后，在缓冲池中的页刷新到持久化存储设备前数据库发生了宕机，那么数据库重启时，可以通过日志来保证数据的完整性。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>InnoDB是事务的存储引擎，其通过<strong>Force Log at Commit 机制</strong>实现事务的持久性，即当事务提交时，先将 redo log buffer 写入到 redo log file 进行持久化，待事务的commit操作完成时才算完成。这种做法也被称为 **Write-Ahead Log(预先日志持久化)**，在持久化一个数据页之前，先将内存中相应的日志页持久化。</p><p>为了保证每次日志都写入redo log file，在每次将redo buffer写入redo log file之后，默认情况下，InnoDB存储引擎都需要调用一次 <strong>fsync操作</strong>,因为重做日志打开并没有 O_DIRECT选项，所以重做日志先写入到文件系统缓存。为了确保重做日志写入到磁盘，必须进行一次 fsync操作。fsync是一种系统调用操作，其fsync的效率取决于磁盘的性能，因此磁盘的性能也影响了事务提交的性能，也就是数据库的性能。<br> <strong>(O_DIRECT选项是在Linux系统中的选项，使用该选项后，对文件进行直接IO操作，不经过文件系统缓存，直接写入磁盘)</strong></p><p>上面提到的<strong>Force Log at Commit机制</strong>就是靠InnoDB存储引擎提供的参数 <code>innodb_flush_log_at_trx_commit</code>来控制的，该参数可以控制 redo log刷新到磁盘的策略，设置该参数值也可以允许用户设置非持久性的情况发生，具体如下：</p><ul><li>当设置参数为1时，（默认为1），表示事务提交时必须调用一次 <code>fsync</code> 操作，最安全的配置，保障持久性</li><li>当设置参数为2时，则在事务提交时只做 <strong>write</strong> 操作，只保证将redo log buffer写到系统的页面缓存中，不进行fsync操作，因此如果MySQL数据库宕机时 不会丢失事务，但操作系统宕机则可能丢失事务</li><li>当设置参数为0时，表示事务提交时不进行写入redo log操作，这个操作仅在master thread 中完成，而在master thread中每1秒进行一次重做日志的fsync操作，因此实例 crash 最多丢失1秒钟内的事务。（master thread是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性）</li></ul><h2 id="原子性的实现"><a href="#原子性的实现" class="headerlink" title="原子性的实现"></a>原子性的实现</h2><p>原子性其实是由持久性和隔离性一起实现的</p><h2 id="一致性的实现"><a href="#一致性的实现" class="headerlink" title="一致性的实现"></a>一致性的实现</h2><p>原子性，隔离性，持久性的体现就是一致性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL锁与事务&quot;&gt;&lt;a href=&quot;#MySQL锁与事务&quot; class=&quot;headerlink&quot; title=&quot;MySQL锁与事务&quot;&gt;&lt;/a&gt;MySQL锁与事务&lt;/h1&gt;&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="-mysql" scheme="http://feelerice.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySql索引</title>
    <link href="http://feelerice.github.io/2021/09/27/MySql%E7%B4%A2%E5%BC%95/"/>
    <id>http://feelerice.github.io/2021/09/27/MySql%E7%B4%A2%E5%BC%95/</id>
    <published>2021-09-27T03:49:22.000Z</published>
    <updated>2021-09-27T07:08:17.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数据库，顾名思义也就是存放数据的地方。这篇文章将会从最基本的数据结构来扩展数据库的设计。</p><h2 id="数据库的数据结构"><a href="#数据库的数据结构" class="headerlink" title="数据库的数据结构"></a>数据库的数据结构</h2><blockquote><p>如果只是单纯的只是用来存放数据，显然线性表是一个最好的选择。线性表中具有按照物理连续空间存放的数组结构，也具有逻辑上连续存储，物理上随机存储的链表结构。</p></blockquote><p>但是在我们使用数据库的经验来看，数据库对于程序员而言并不只是一个单纯的存储数据的地方。我们还经常按照一些需求来对数据库进行增删改查，其中查是我们用的最多的情况，按照某个字符来进行升降序的查询也是非常常见的操作。显然如果我们使用线性表来存储输出，那就是一个非常大的事件开销。那么我们有没有比线性表更好的存储结构呢？</p><blockquote><p>二叉树，顾名思义二叉树就是一个节点上最多有两个子节点的树。</p></blockquote><p>如果我们使用了二叉树来进行数据的存储，那么我们可以根据数据的某一项进行排序存储。对于任意节点的数据来说左节点的值都是比当前值要小，右节点都比当前节点的值大。而且二叉树对于查找的效率十分接近于二分查找，查找速度非常快的。</p><p>但是，我们在使用二叉树的时候有一个非常重要的事，那就是二叉树的退化。所谓二叉树的退化也就是在增删改查的过程中会导致二叉树退化成为一个链表。如下图所示：</p><p><img src="/2021/09/27/MySql%E7%B4%A2%E5%BC%95/2tree.png"></p><p>当二叉树的构成变成这样的之后，就会导致当前的二叉树失去他作为二叉树的一切优点还会比普通的链表消耗更多的内存（一个节点有连个子节点指针）。那么有什么方式可以防止二叉树的退化呢？</p><blockquote><p>AVL也就是平衡二叉树一种实现，其要求如下：</p><p>对于任意节点，左节点和右节点的高度差的绝对值不能大于1。</p></blockquote><p>尽管AVL 平衡二叉树在查找速度上已经能够满足大部分条件。但是，在大数据，比如百万级别的数据的查找效率上仍然达不到我们的期望。 从操作系统的角度上讲，每次计算机处理数据都是从内存中读取，如果内存中没有所需要的数据，就通过磁盘IO把数据加载到内存中。 把数据从外存读到内存所使用的单位一般被称为“页”，每次读取数据都需要读入整数个的“页”，而不能读入半页或者0.8页。一页的大小由操作系统决定。很显然，当你不知道下一次磁盘读取能否命中的情况下，你选择一页一页地读取，读取之后进行判断。且你需要知道，磁盘不是需要啥加载啥，它会顺便把相邻的数据也一块加载到内存中作为缓存。在这种情况下，如果采用AVL平衡二叉树，每次都取一个结点，判断大小，代价是很高的。假设一次磁盘IO是10ms，如果百万级别的数据，树高为20就是2秒。那么有没有优化策略呢？</p><blockquote><p>B树，也叫多路查找树，也就是每个节点多存了一些数据。</p><p>对于M阶B树：有如下性质<br>        1）每个节点至多有M个子节点；<br>        2）有K个子节点的非叶子节点中包含K-1个键（Key）;<br>        3）根节点至少有两个子节点（如果此时B-树不仅只有根节点）；<br>        4）每个非叶子节点（根节点除外）至少有Ceil[M/2]个子节点；这里Ceil表示向上取整；<br>        5）所有的叶子节点都在同一层。</p></blockquote><p>对于B树而言似乎对我们的系统而言已经十分完美了，但是如果我们考虑到到每一个节点都存有数据，那么当数据过多的时候就无法避免的多进行几次IO，那么能不能减少几次IO操作呢？</p><blockquote><p>B+树，其大多数性质和B树一样，但是B+树也有自己的特性</p><ol><li><p>非叶子节点只存放由索引有关的数据，不存放具体数据</p><p>例如：有一张表（id，name，school，addr，phone，date）如果我们按照id来进行查找，那么对于B+树而言，他的非叶子节点上的数据就只会存放id，而其它数据都存放在叶子节点上。</p></li><li><p>每一个叶子节点都有一个指针指向下一个叶子节点</p></li></ol></blockquote><p>到此，我们就可以知道MySQL数据库的底层使用的是B+树了。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在上面的描述中，其实我们就可以知道索引是一个什么东西了，索引就是一个为了更方便查找数据用来存放在非叶子节点上的排序索引。</p><p>那么现在我们有个问题，数据库的表可以建立不止一个索引，那么如果每个索引的叶子节点上都存放数据。那么数据是不是就产生了很大的冗余，其实在MySQL的InnoDB引擎为了解决这个问题，提出了聚簇索引和非聚簇索引。</p><ul><li> 聚簇索引：其叶子节点直接存放的就是数据的所有信息，其也确定了数据的物理排序顺序。</li><li>非聚簇索引：叶子节点存放的并不是数据的全部信息，而是存放的聚簇索引的索引值</li></ul><p>对于InnoDB引擎而言他会在建立表的时候会创建一个聚簇索引</p><ul><li>若表存在主键，那么主键是聚簇索引</li><li>若没有主键，那么其唯一非空的列成为聚簇索引的索引值</li><li>若都不存，那么InnoDB会自动创建一个6字节的隐藏逐渐</li></ul><p>对于MyISAM引擎而言他只存在非聚簇索引</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL索引&quot;&gt;&lt;a href=&quot;#MySQL索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引&quot;&gt;&lt;/a&gt;MySQL索引&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://feelerice.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://feelerice.github.io/2021/09/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://feelerice.github.io/2021/09/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-09-26T02:39:18.000Z</published>
    <updated>2021-10-04T08:20:12.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《Java虚拟机规范》一书中曾经视图定义一种“Java内存模型”来屏蔽各种硬件和操作系统的内存访问差异，以实现Java程序能够在各种不同的平台下能够达到一致的内存访问效果。在此之前，主流编程语言(C、C++)都是直接使用物理硬件和操作系统的内存模型。因此，对于不同平台的程序，很有可能出现在一套平台上可以正常运行而在另外一套平台上却不能够正常运行。</p><p>定义一套内存模型并不是一件容易的事，这个模型必须足够严谨，才能让Java的并发内存访问操作不会产生歧义；但是也必须定义的足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性来获取更好的执行速度。经过长时间的验证和补修，知道JDK5发布后Java内存模型才终于成熟。完善起来了。</p><h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中吧变量赋值到内存和从内存中取出变量值这样的底层操作。</p><p>Java内存模型规定了所有变量都存放在主内存（Main Menory）中。每条线程有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程堆变量的所有操作（读取，赋值）都必须在工作内存中进行，线程间变量值的传递觉需要通过内存来完成，线程。主内存、工作内存之间的交互关系如下所示：</p><p><img src="/2021/09/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/jmm.png"></p><h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>关于主内存与工作内存之间的具体交互，Java内存模型定义了以下8中操作来完成。Java虚拟机必须保证下面提及的每一种操作都是原子的，不可再分的（double、long有特例）</p><ol><li>lock（锁定）：作用于主内存的变量，他把一个变量标识为线程独占的状态</li><li>unlock（解锁）：作用于主内存的变量，他把一个处于lock状态的变量释放出了，释放后的变量才能被其他线程lock。</li><li>read（读取）：作用于主内存中的变量，他把一个变量的值从主内存传输到线程的工作内存中</li><li>write（写入）：作用域主内存，他把一个变量从工作内存中写回主内存</li><li>load（载入）：作用域工作内存，他把read操作获取的值放入工作内存</li><li>store（存储）：作用域工作内存的变量，他把工作内存中的一个变量的值传送到主内存中</li><li>use（使用）：作呕能够与工作内存的变量，他把工作内存中的一个值赋予给执行引擎，当执行引擎虚拟机遇到一个需要使用变量的值的字节码指令时会执行这个操作。</li><li>assign（赋值）：作用域工作内存的变量，他把一个从执行引擎接受的值赋给工作内存的变量</li></ol><p>除此之外，Java内存模型还规定了执行上述8中基本操作时必须满足如下规则：</p><ul><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃他最近的assgin操作</li><li>不允许一个线程不发生assgin操作的时候读取一个变量</li><li>一个变量在同一时刻只允许一个线程对其进行lock操作，但是一条线程可以对一个变量进行多次lock操作，但之后只有执行了相同数量的unlock操作之后，其他线程才能执行lock操作</li><li>如果对一个变量先没有被lock操作，就不允许有unlock操作</li><li>对一个变量进行unlock操作之前不许吧变量同步到主内存中（store、write操作）</li><li>一个变量只能在主内存中“诞生”，不允许在工作内存中直接是哦那个一个未被初始化（load。assign）的变量</li><li>如果一个变量执行lock操作，那将会清空工作内存中此变量的值，再执行引擎是哦那个到这个变量之前，需要重新load或assign操作已初始化变量的值</li></ul><p>上面8条内存访问以及上述规则限定，再加上一些专门用于volatile的特殊规则，就能够精准描述出Java程序中那些内存访问操作在并发下是安全的。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>关键字volatile可以说时Java虚拟机提供的最轻量级的同步机制，但是他并不容易被正确，完整的理解。Java内存模型为volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，先用一些不那么正式，但通俗易懂的语言介绍这个关键字的作用</p><p>当一个变量被定义为volatile之后，它将会具有两条特性</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>保证此变量对其他所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说都是立刻得知的。</p><p>但是对于volatile的可见性，经常被人误解为：“volatile变量对所有线程是立即可见的，堆volatile变量所有的读写操作都能立即反应到其他线程中，换一句换锁，volatile变量在各个线程中是一致的，所以基于volatile变量运算在并发下是线程安全的”。我们可以通过以下代码来验证他的正误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch downLatch = <span class="keyword">new</span> CountDownLatch(NUMBER);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    increase();</span><br><span class="line">                &#125;</span><br><span class="line">                downLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        downLatch.await();</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用了是个线程，每个线程调用1000次increase()方法，如果volatile时线程安全的，那么最后输出的结果应该时10000。实际上我们很难有成功输出10000的时候，这是由于在对num++这个操作的时候，我们可以通过字节码来查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>;</span><br><span class="line">   Code:</span><br><span class="line">      <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">      <span class="number">3</span>: iconst_1</span><br><span class="line">      <span class="number">4</span>: iadd</span><br><span class="line">      <span class="number">5</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">      <span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>我们可以看到在increase()方法的字节码指令，num++被分解成了四步操作，这导致了每一步操作都有可能被其他线程所拦截。所以说volatile只能保证可见性，而不能保证线程安全。</p><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>禁止指令重排序优化，普通变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序于程序代码中执行顺序是一样的。</p><h3 id="指令重排序案例"><a href="#指令重排序案例" class="headerlink" title="指令重排序案例"></a>指令重排序案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="comment">// 可能出现的结果</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1, 0&quot;,&quot;4, 0&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;Default outcome.&quot;)</span></span><br><span class="line"><span class="comment">// 我们感兴趣的结果（指令重排序所产生的结果）</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0, 0&quot;,expect = Expect.ACCEPTABLE_INTERESTING,desc = &quot;Interesting&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程1</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(II_Result r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ready)&#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(II_Result r)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码的r.r1的执行结果：</p><ul><li>线程1先执行，此时ready = false，所以结果为false语句块，答案为1</li><li>线程2先执行到num = 2，此时还没执行ready = true就切会线程1执行，所以答案还是为1</li><li>线程2先执行到ready = true，此时num = 2，所以线程1在执行的时候就会进入true语句块，答案为4</li></ul><p>这几种结果都是我们很容易预测的，但是其实在Java的编译过程中为了而提高执行效率而有可能发生指令重排序导致出现以下结果：</p><ul><li>num = 2 和 ready = true发生重排序，在线程2中ready = true先于num = 2执行，那么此时线程1进入true的判断，答案为0</li></ul><p>下面我们使用一个maven语句来创建一个骨架来进行验证会不会真的出现这种情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test-archetype -DarchetypeVersion=0.5 -DgroupId=com.lp.test -DartifactId=ordering -Dversion=1.0</span><br></pre></td></tr></table></figure><p>创建股价成功之后，我们将其打成jar包后运行，结果如下：</p><p><img src="/2021/09/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/volatileDemo.png"></p><p>我们可以看出“0, 0”的结果出现了5388次，虽然说这个比例很小，但是最终却还是出现了。</p><p>我们修改代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span>  ready = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>然后我们重新打包，在执行一次，结果如下：</p><p><img src="/2021/09/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/.%5CJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%5CvolatileDemo2.png"></p><p>在INTERESTING一项中的结果为0，所以说volatile可以防止指令重排</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><ul><li>写屏障：保证在写屏障之前的赋值操作都应该写回到主内存中</li><li>读屏障：保证在读屏障之后的读操作都应该从主存中读取</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant t1 as t1 线程 </span><br><span class="line">participant num as num = 0 </span><br><span class="line">participant ready as volatile ready = false </span><br><span class="line">participant t2 as t2 线程 </span><br><span class="line">t1 --&gt;&gt; t1 : num = 2</span><br><span class="line">t1 -&gt;&gt; ready : ready = true</span><br><span class="line">Note over t1,ready: 写屏障</span><br><span class="line">Note over num,t2: 读屏障</span><br><span class="line">t2 -&gt;&gt; ready: 读取ready = true</span><br><span class="line">t2 -&gt;&gt; num : 读取num=2</span><br></pre></td></tr></table></figure><h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>如果Java内存模型中所有的有序性都依赖于volatile和synchronized来完成，那么很多操作就会变得非常罗嗦，但我们在编写Java代码的时候并没有感受到这一点，这是因为Java语言中有一个“先行发生”（Happens-Before）原则。</p><p>下面我们举一个例子来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下操作在A线程进行</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="comment">//以下操作在B线程进行</span></span><br><span class="line">j = i    </span><br><span class="line"><span class="comment">//以下操作在C线程中执行</span></span><br><span class="line">i = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>假设A线程先于B线程执行，那么我们可以确定j = 1，这是因为C线程还没有执行和A线程执行完全之后的值可以被B线程观测到。但是现在如果C线程在A、B线程之间执行，那么j的值就不确定了，他可能时1也可能是2，这个时候B线程就有线程安全问题了。</p><p>下面时Java内训模型下的一些“天然的”先行发生关系，这些先行发生关系无需任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则中导出来，则它们就没有顺序性保障，虚拟机可以对他们随意的进行重排序。</p><ul><li><strong>程序次序规则</strong>：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于后面的操作。注意这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支，循环等结构</li><li><strong>管程锁定规则</strong>：一个unlock操作先行发生于对同一个锁的lock操作。这里必须强调的是“同一个锁”，而后面指的是时间上的先后顺序</li><li><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面指的是时间上的先后顺序</li><li><strong>线程启动规则</strong>：Thread对象的start()方法先行发生于此线程的每一个动作</li><li><strong>线程终止规则</strong>：线程中所有操作都先行发生于此线程的终止</li><li><strong>线程中断规则</strong>：对线程的interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li><strong>对象终结规则</strong>：一个对象的初始化完成先于他的finalize()方法</li><li><strong>传递性</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那么就可以得出操作A先行发生于操作C</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://feelerice.github.io/tags/JVM/"/>
    
    <category term="JMM" scheme="http://feelerice.github.io/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>CAS与volatile关键字</title>
    <link href="http://feelerice.github.io/2021/09/26/CAS/"/>
    <id>http://feelerice.github.io/2021/09/26/CAS/</id>
    <published>2021-09-26T00:38:39.000Z</published>
    <updated>2021-09-26T02:39:40.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们知道在Java中有两种办法可以实现锁的机制，一种是由Java虚拟机所提供的synchronized关键字。而另外一种就是CAS 和volatile关键字搭配使用所实现的锁机制了。</p><h2 id="手写锁"><a href="#手写锁" class="headerlink" title="手写锁"></a>手写锁</h2><p>CAS是Compare And Swap的检查，也就是比较并交换。其具体的实现就是Unsafe类和volatile关键字所实现的。下面我们可以通过Unsafe类和volatile关键字，先体验以下手动实现一个锁。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//锁的状态，0表示现在没有锁，1表示当前有锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            unsafe = getUnsafe();</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(SpinLock.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpinLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!unsafe.compareAndSwapInt(<span class="keyword">this</span>,valueOffset,<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line"><span class="comment">//            System.out.println(Thread.currentThread().getName() + &quot; ==  自旋中，等待获取锁&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unsafe.compareAndSwapInt(<span class="keyword">this</span>,valueOffset,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        SpinLock lock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">        Runnable run = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=============================== 获得了锁&quot;</span>);</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(run,<span class="string">&quot;Thread - &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><p><img src="/2021/09/26/CAS/casprint.png"></p><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS,compare and swap的缩写，中文翻译成比较并交换。</p><p>我们都知道，在java语言之前，并发就已经广泛存在并在服务器领域得到了大量的应用。所以硬件厂商老早就在芯片中加入了大量直至并发操作的原语，从而在硬件层面提升效率。在intel的CPU中，使用cmpxchg指令。</p><p>在Java发展初期，java语言是不能够利用硬件提供的这些便利来提升系统的性能的。而随着java不断的发展,Java本地方法(JNI)的出现，使得java程序越过JVM直接调用本地方法提供了一种便捷的方式，因而java在并发的手段上也多了起来。而在Doug Lea提供的cucurenct包中，CAS理论是它实现整个java包的基石。</p><p>CAS 理论上的目标参数应该只有三个，也就是，V（内存位置）、O（旧的值）、N（新的值）。只需要这三个参数就可以进行CAS操作了，但是在上面的代码中我们却又这样一行unsafe.compareAndSwapInt(this,valueOffset,0,1)，这是因为在Java中由于内存管理是由Java虚拟机代替程序员所管理的，所以在程序运行的过程之中，数据所存储的内存位置在发生变化，但是又由于每一次GC将对象的内存位置变化之后，又必须通知程序员的对象引用新的内存位置在哪里，所以Unsafe需要使用this来表示我们要修改哪一个对象的valueoffse那个位置上的变量。</p><h2 id="实现CAS需要遇到的问题"><a href="#实现CAS需要遇到的问题" class="headerlink" title="实现CAS需要遇到的问题"></a>实现CAS需要遇到的问题</h2><p>但是CAS存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p><ol><li><strong>ABA问题</strong>：这一个问题并不在我们上面的代码中可以体现出来，不过如果state的变量的修饰符是public的，那么就会有人在其他地方修改state的值为0（当前无锁状态），那么这个时候就会产生一个问题：如果A线程获得了锁此时state的数据从0变成了1，H线程修改了state的值（从1改回了0），那么对于B线程要进行加锁操作的时候，对他而言现在的state是0（没有其他线程获得了锁），它可以进入同步代码块，所以这个时候很有可能会产生线程安全问题。这就是ABA问题，对于这个问题的解决方案，我们是个数据添加一个版本号。</li><li><strong>循环时间长</strong> ，开销大：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li><li><strong>只能保证一个共享变量的原子操作</strong>：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了<strong>AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</strong></li></ol><p>对于Java实现CAS的基础，volatile关键字的讲解我们将放在《Java内存模型》讲解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAS&quot;&gt;&lt;a href=&quot;#CAS&quot; class=&quot;headerlink&quot; title=&quot;CAS&quot;&gt;&lt;/a&gt;CAS&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    
    <category term="锁" scheme="http://feelerice.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收器</title>
    <link href="http://feelerice.github.io/2021/09/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://feelerice.github.io/2021/09/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</id>
    <published>2021-09-25T07:40:09.000Z</published>
    <updated>2021-09-26T00:38:06.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>各款经典垃圾回收器之间的关系如图所示：</p><p><img src="/2021/09/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/garbages.png"></p><h2 id="年轻代垃圾回收器"><a href="#年轻代垃圾回收器" class="headerlink" title="年轻代垃圾回收器"></a>年轻代垃圾回收器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>Serial垃圾回收器是最基础，历史最为悠久的垃圾回收器，曾今在JDK1.3之前是HotSpot虚拟机新生代收集器的唯一选择。</p><p>Serial垃圾回收器是一款单线程工作的收集器，他的“单线程”的意义不仅仅说明他只会使用一个处理器或者一条收集线程去完成垃圾收集工作，更重要的是强调他在进行垃圾回收的时候，必须停止其他所有工作线程，直到它工作完成。“Stop The World”这项工作是由虚拟机在后台自动发起和自动结束的，在用户不可知，不可控的情况下把用户的正常工作的线程全部停掉，这对很多应用来说是不能接受的。</p><p>下面是Serial垃圾回收器的工作示意图</p><p><img src="/2021/09/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/Serial.png"></p><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>ParNew垃圾回收器实质上来说就是Serial垃圾回收器的多线程版本，除了同时使用多条线程进行垃圾回收之外，其余行为包括Serial垃圾回收器可用的所有控制参数，垃圾收集算法，Stop The World，对象分配规则，回收策略等都与Serial垃圾回收器一模一样。并且在实现这两种垃圾回收器代码也有相当之多的复用。</p><p>下面是ParNew垃圾回收器的工作示意图</p><p><img src="/2021/09/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/ParNew.png"></p><h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>Parallel Scavenge垃圾回收器同样是基于标记-复制算法实现的垃圾回收器，也是能够并行收集的多线程垃圾回收器，从许多方面来看Parallel Scavenge垃圾回收器和ParNew垃圾回收器都非常相似，那么它有什么特别的地方吗？</p><p>实际上Parallel Scavenge垃圾回收器的特点是他的关注点与其他收集器不同，CMS等垃圾收集器的关注点是尽可能的缩短垃圾收集时的用户线程的停顿事件，而Parallel Scavenge垃圾收集器的目标则是可达到一个可控的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的事件于处理器总消耗时间的比值，即</p><p><img src="/2021/09/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/Throughput.png"></p><p>例如：在执行某一个任务的时候，用户代码执行了99分钟，而垃圾回收器执行了1分钟，那么吞吐量就是99%。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应素服能够提升用户体验；而高吞吐量则可以高效率的利用处理器资源，尽快完成程序的运算任务。</p><p>Parallel Scavenge垃圾回收器提供了两个参数用于精确控制吞吐量</p><blockquote><p>控制最大垃圾收集停顿时间：-XX:MaxGCPauseMillis</p><p>设置吞吐量大小的参数：-XX:GCTimeRatio</p></blockquote><h2 id="老年代垃圾回收器"><a href="#老年代垃圾回收器" class="headerlink" title="老年代垃圾回收器"></a>老年代垃圾回收器</h2><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p>Serial Old垃圾回收器是Serial垃圾回收器的老年代版本，它同样是一个单线程垃圾回收器，使用标记整理算法。这个垃圾收集器的主要意义也是提供客户端模式下的HotSpot虚拟机使用。如果是在服务端模式下，他有两个用途：一种是子啊JDK1.5之前的版本中与Parallel Scavenge垃圾收集器搭配使用，另外就是作为CMS垃圾回收器失败之后的备选方案，在并发收集发生Concurrent Mode Failure时使用。</p><p>其工作示意图如下所示</p><p><img src="/2021/09/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/Serial.png"></p><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>Parallel Old是Parallel Scavenge垃圾回收器的老年代版本，支持多线程并行收集，基于标记-整理算法实现。这个垃圾回收器是知道JDK1.6才提供的，在此之前新生代的Parallel Scavenge垃圾收集器一直都处于一个非常尴尬的状态，原因如果新生代选择了Parallel Scavenge垃圾收集器之后那么老年代就只有Serial Old垃圾收集器可以选择。在现在来看只要是注重吞吐量或者处理器资源较为稀缺的场合和都可以选择Parallel Scavenge加上Parallel Old来搭配使用</p><p>其工作示意图如下</p><p><img src="/2021/09/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/ParNew.png"></p><h3 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h3><p>CMS(Concurrent Mark Sweep)垃圾回收器是一种以获取最短回收停顿时间为目标的垃圾回收器，目前很大一部分的Java应用集中于互联网网站或者基于浏览器的额B/S系统的服务端上，这类应用通常较为关注服务的响应素服，希望系统停顿时间尽可能短，以给用户带来更好的交互体验。CMS垃圾回收器就非常符合这类应用的需求。</p><p>从名字来看（包含了Mark Sweep）就能知道CMS垃圾回收器是基于标记-清除算法实现的，它的运作过程下对于前集中垃圾收集器来说要更加复杂一点，整个过程分为四个步骤，包括：</p><ol><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ol><p>其中初始标记，重新标记这两个步骤依旧需要“Stop The World”。初始标记仅仅只是标记了一下GC Root能够直接关联到的对象，速度很快；并发标记阶段就是从GC Root的直接关联对象开始遍历整个对象图的过程，这个过程消耗时间较为长但是不需要暂停用户线程，可以于垃圾回收线程一起并发运行；而重新标记阶段则是为了修正并发标记期间的，因用户程序继续运作而导致标记产生变动的一小部分对象的标记记录，这个阶段的暂停时间通常比初始标记的暂停时间更长一点，但也远比并发标记阶段的时间短；而后一个就是并发清除阶段，清理删除标记阶段判断已经死亡的对象，这个阶段也适合用户线程并发执行的。</p><p>下面是CMS垃圾收集器的工作示意图</p><p><img src="/2021/09/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/cms.png"></p><p>CMS是一款优秀的垃圾回收器，它主要的优点在名字上就已经体验出来了：并发收集，低停顿。但是CMS并不是完美的它至少含有以下三个明显的缺点</p><ol><li>CMS垃圾回收器对处理器资源十分敏感。事实上，面向并发设计的垃圾回收器对处理器资源都十分敏感。在并发阶段，她虽然不会导致用户线程暂停，但是却会因为占用了一部分线程而会导致引用程序变慢，吞吐量降低。CMS默认开启的回收线程数量为：开启的线程数 = （处理器核心数 + 3）/4.也就是说，在处理器核心数大于4的形况下，CMS垃圾回收线程占用不少于25的处理器运算资源，并且会随着处理器核心数的增加而降低。但是当处理器核心不足4个的时候，CMS对用户程序的影响就会很大了，如果引用程序的负载本来就很大，还要分出一半的运算能力去执行垃圾回收线程，就会导致用户程序的执行速度忽然大幅度下降</li><li>CMS垃圾回收器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Concurrent Mode Failure”失败而进入另一次完全“Stop The World”而导致Full GC的产生。在CMS的并发标记和并发清除阶段，用户线程是还在继续用作的，程序就自然而然地会产生垃圾，但是这一部分产生的垃圾实在标记过程之后产生的，所以只能等待下一次垃圾回收在进行清除。同样的由于在垃圾回收阶段用户线程还在继续执行，所以CMS也无法像其他垃圾回收器一样等到老年代几乎要满的情况下在进行垃圾回收，CMS是要在老年代还保留一部分内存的情况下就要进行垃圾回收，在JDK5中CMS触发为当老年代使用了68%之后就会进行，我们也可以通过参数-XX:CMSInitiatingOccu-pancyFraction的值来提升触发CMS的百分比。到了JDK6，CMS的触发值为92%，这样就会面临另外一个风险，要是再CMS运行期间发生了“Concurrent Mode Failure”，这个时候虚拟机将不得不启动后备方案：冻结所有用户线程并执行Serial Old的垃圾回收器来进行老年代的垃圾回收，这样就会导致用户线程暂停时间变得更久。</li><li>最后一个缺点就是器算法的缺点，由于CMS采用的是标记-清除算法，那么在垃圾回收的时候将会产生很多内存碎片。内存碎片过多的情况下，大对象明明有足够的内存可以放下，但由于都是内存碎片，这样就会导致提前的Full GC。</li></ol><h2 id="Garbage-First"><a href="#Garbage-First" class="headerlink" title="Garbage First"></a>Garbage First</h2><p>G1是一款主要面向服务端应用的垃圾回收器。在G1之前的所有垃圾回收器包括CMS在内，垃圾收集的目标范围要不就是整个新生代（Minor GC）要不就是整个老年代（Major GC），在要么就是整个Java堆（Full GC）。而G1则跳出了这个牢笼，它可以面向堆内存任何部分组成回收集（Collection Set，一般称之为C Set）进行回收，衡量标准不再是它属于那个分代，而是那块内存中存放的垃圾数量最多，回收收益最大，这就是G1垃圾回收器的Mixed GC模式。</p><p>G1开创的基于Region的堆内存布局使它能够实现这一目标的关键。虽然G1也遵从分代收集理论设计的，但是其在对内存的分布与其他垃圾回收器有非常明显的差异；G1不在坚持固定大小以及固定数量的分代区域划分，而是把连续的Java对划分为多个大小相等的独立区域（Region），每一个Region都可以更具需要，扮演新生代的Eden看空间，Survivor空间或者是老年代空间。垃圾回收器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间，熬过多次垃圾回收的就对象都能获取很好的收集效果。Region中还有一类特殊的Humongous区域，专门用来存放大对象。每个Region的大小可以通过JVM参数 -XX:G1HeapRegionSize设定，取值范围为（1MB - 32MB），且应该为2的N次幂。对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来看待，如下图所示。</p><p><img src="/2021/09/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/regions.png"></p><p>G1垃圾回收器的运作过程大致可以分为以下四个步骤：</p><ol><li><strong>初始标记</strong>（Initial Marking）：仅仅只是标记了一下GC Roots能够直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用的Region中分配新对象。这一个阶段需要暂停线程，但耗时很短，而且是借用于Minor GC的时候同步完成的，所以G1垃圾回收器在这一阶段并没有额外的停顿。</li><li><strong>并发标记</strong>（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可以与用户程序并发执行。当对象图扫描完成以后，还需要重新处理SATB记录下来的在并发时有引用变动的对象。</li><li><strong>最终标记</strong>（Final Marking）：对用户现场做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录</li><li><strong>筛选回收</strong>（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自荣选择任意多个Region构成会收集，然后决定回收的那一部分Region的存活对象复制到空的Region中去，在清理掉整个旧的Region的全部空间。这里的操作设计存活对象的移动，是必须暂停用户线程，有多个收集器线程并行完成的。</li></ol><p>与CMS的“标记-清除算法”不同，G1从整体来看是基于“标记-整理算法”来实现的，但从局部来看G1又是基于“标记-复制算法”实现。这两种算法都意味着G1在运行期间不会产生内存空间碎片。</p><p>Garbage First的工作示意图如下：</p><p><img src="/2021/09/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/g1.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th align="center">垃圾回收器</th><th align="center">适用范围</th><th align="center">采用算法</th></tr></thead><tbody><tr><td align="center">Serial</td><td align="center">新生代</td><td align="center">复制算法</td></tr><tr><td align="center">Serial Old</td><td align="center">老年代</td><td align="center">标记整理算法</td></tr><tr><td align="center">ParNew</td><td align="center">新生代</td><td align="center">复制算法</td></tr><tr><td align="center">Parallel Scavenge</td><td align="center">新生代</td><td align="center">复制算法</td></tr><tr><td align="center">Parallel Old</td><td align="center">老年代</td><td align="center">标记整理算法</td></tr><tr><td align="center">CMS</td><td align="center">老年代</td><td align="center">标记清除算法</td></tr><tr><td align="center">G1</td><td align="center">全部</td><td align="center">标记复制，标记整理</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收器&quot;&gt;&lt;a href=&quot;#垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收器&quot;&gt;&lt;/a&gt;垃圾回收器&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://feelerice.github.io/tags/JVM/"/>
    
    <category term="垃圾回收" scheme="http://feelerice.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java锁</title>
    <link href="http://feelerice.github.io/2021/09/24/Java%E9%94%81/"/>
    <id>http://feelerice.github.io/2021/09/24/Java%E9%94%81/</id>
    <published>2021-09-24T11:58:04.000Z</published>
    <updated>2021-09-24T14:53:13.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h1><h2 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h2><p>在现在的绝大多数应用程序都是支持多线程的，虽然说多线程可以大幅度提升CPU的利用率，但是在我们在使用多线程进行并发开发的时候却必须解决线程安全问题。线程安全问题：也就是可能存在多个线程对同一个目标资源的争抢，导致资源出现错误。而我们的解决方案就是对于<strong>要发生争抢的资源</strong>放在同步代码块中进行操作，这要就可以实现每一次对资源只有一个线程进行操作。对于实现这个解决方案的方法就是提供一个标识符表示当前这个资源有没有其他线程在操作，如果有就等待。如果没有，那么自己线程就持有锁并操作资源。</p><h2 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h2><p>在Java语言中实现锁的最常见的方式有两种：<strong>synchronized</strong>关键字和<strong>JUC包下的ConcurrentLock()类</strong>。</p><h3 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h3><p>这个是JVM为用户所提供的锁。其作用范围为：</p><ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其（）中的对象作为锁 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(SynchronizedDemo.class)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修饰一个方法，被修饰的方法被称为同步方法，其实例化的不同对象作为不同的锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method02A</span><span class="params">()</span></span>&#123;</span><br><span class="line">       i ++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method02B</span><span class="params">()</span></span>&#123;</span><br><span class="line">       i ++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注：如果一个类中有两个倍synchronized修饰的方法，那么他们是公用一把锁的，也就是当1号线程通过a对象调用了了method02A()，此时另外2号线程也想通过a对象调用method02B()方法他也是不能够进入的，只能等待1号线程结束了method02A()方法的调用才能进入method02B()方法。但是如果2号线程通过b对象调用method02B()是不会被阻塞的。</p><ol start="3"><li>修饰一个静态代码块，其Class对象作为锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock锁："><a href="#ReentrantLock锁：" class="headerlink" title="ReentrantLock锁："></a>ReentrantLock锁：</h3><p>其不能修饰方法，主要使用方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> self)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           lock.lock();</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">           *同步代码</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">       &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下我们都是将lock.unlock()的调用放在finally代码块之中，以保证锁一定能够释放。</p><h2 id="锁的原理"><a href="#锁的原理" class="headerlink" title="锁的原理"></a>锁的原理</h2><h3 id="synchronized锁-1"><a href="#synchronized锁-1" class="headerlink" title="synchronized锁"></a>synchronized锁</h3><p>为解释synchronized锁的原理，我们需要查看代码的字节码，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(SynchronizedDemo.class)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其对应的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> ldc #<span class="number">2</span> &lt;com/lp/JUC/SynchronizedDemo&gt;</span><br><span class="line"> <span class="number">2</span> dup</span><br><span class="line"> <span class="number">3</span> astore_1</span><br><span class="line"> <span class="number">4</span> monitorenter</span><br><span class="line"> <span class="number">5</span> getstatic #<span class="number">3</span> &lt;com/lp/JUC/SynchronizedDemo.i&gt;</span><br><span class="line"> <span class="number">8</span> iconst_1</span><br><span class="line"> <span class="number">9</span> iadd</span><br><span class="line"><span class="number">10</span> putstatic #<span class="number">3</span> &lt;com/lp/JUC/SynchronizedDemo.i&gt;</span><br><span class="line"><span class="number">13</span> aload_1</span><br><span class="line"><span class="number">14</span> monitorexit   </span><br><span class="line"><span class="number">15</span> goto <span class="number">23</span> (+<span class="number">8</span>)</span><br><span class="line"><span class="number">18</span> astore_2</span><br><span class="line"><span class="number">19</span> aload_1</span><br><span class="line"><span class="number">20</span> monitorexit   </span><br><span class="line"><span class="number">21</span> aload_2</span><br><span class="line"><span class="number">22</span> athrow</span><br><span class="line"><span class="number">23</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>我们可以看到在第4行有一个monitorenter、在10，14行有monitorexit字节码。这个就是在虚拟机层面为我们实现的锁机制。而之所以有两个monitorenter的原因是为了在程序发生异常的时候也能够释放锁，不必阻塞之后的线程。</p><h3 id="ReentrantLock锁"><a href="#ReentrantLock锁" class="headerlink" title="ReentrantLock锁"></a>ReentrantLock锁</h3><p>其原理主要是使用了CAS来实现的。</p><p>在我们创建ReentrantLock实例的时候，其实底层创建了一个继承于AbstractQueuedSynchronizer的类实例，我们每一次调用lock()方法都会触发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update)</span><br></pre></td></tr></table></figure><p>这一句代码，这一句代码就是通过CAS和来实现的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java锁&quot;&gt;&lt;a href=&quot;#Java锁&quot; class=&quot;headerlink&quot; title=&quot;Java锁&quot;&gt;&lt;/a&gt;Java锁&lt;/h1&gt;&lt;h2 id=&quot;锁的概念&quot;&gt;&lt;a href=&quot;#锁的概念&quot; class=&quot;headerlink&quot; title=&quot;锁的概念&quot;</summary>
      
    
    
    
    
    <category term="多线程" scheme="http://feelerice.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="锁" scheme="http://feelerice.github.io/tags/%E9%94%81/"/>
    
    <category term="Java" scheme="http://feelerice.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>线程的定义与状态</title>
    <link href="http://feelerice.github.io/2021/09/24/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%8A%B6%E6%80%81/"/>
    <id>http://feelerice.github.io/2021/09/24/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%8A%B6%E6%80%81/</id>
    <published>2021-09-24T07:48:12.000Z</published>
    <updated>2021-09-25T07:37:32.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的定义与状态"><a href="#线程的定义与状态" class="headerlink" title="线程的定义与状态"></a>线程的定义与状态</h1><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在早期的操作系统中是没有线程的概念的，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。现在绝大多数的操作系统都引入线程的概念，让其作为操作系统的最小运行单位。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>早在单核CPU的时代，就已经有操作系统支持多线程进行了，其归根到底的原因是：由于CPU的运算效率远远高于内存IO的读写效率，所以只有一个程序执行的时候CPU是出于资源浪费阶段的，而多线程则可以更好的榨取CPU的性能。</p><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h3><p>第一种方式是最为简单，最为基础的方式，继承Thread类并且重写run()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread01</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;Over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread01 thread = <span class="keyword">new</span> Thread01();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.setName(<span class="string">&quot;Thread - Test - &quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;Over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="/2021/09/24/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%8A%B6%E6%80%81/print01.png" alt="输出"></p><h3 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h3><p>实现Runnable接口和实现Thread类一样，重写Runnable接口中的run()方法，将其实例传入Thread类的实例并调用start()方法即可。</p><p>其优点相对于继承Thread类来说，由于Java是单继承多实现模式，所以一个类只能由一个父类而采用继承Thread类的方式就不能在继承其他父类了，但是如果采用实现Runnable接口的方式既可以继承其他类也可以可以实现其他接口。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;Over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> RunnableTest();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable,<span class="string">&quot;Runnable - Thread - &quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;Over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="/2021/09/24/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%8A%B6%E6%80%81/print02.png"></p><h3 id="3-实现Callable"><a href="#3-实现Callable" class="headerlink" title="3.实现Callable"></a>3.实现Callable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;Over&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Over&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CallableTest call = <span class="keyword">new</span> CallableTest();</span><br><span class="line">        FutureTask task = <span class="keyword">new</span> FutureTask&lt;String&gt;(call);</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        thread.setName(<span class="string">&quot;Callable - Thread - &quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;Over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="/2021/09/24/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%8A%B6%E6%80%81/print03.png"></p><h3 id="4-使用线程池实现"><a href="#4-使用线程池实现" class="headerlink" title="4.使用线程池实现"></a>4.使用线程池实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        pool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  <span class="string">&quot; - &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +  <span class="string">&quot; Over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="/2021/09/24/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%8A%B6%E6%80%81/print04.png"></p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ol><li>**初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。</li><li>**运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li><li>**阻塞(BLOCKED)**：表示线程阻塞于锁。</li><li>**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。</li><li>**终止(TERMINATED)**：表示该线程已经执行完毕。</li></ol><p>在Thread内中有一个内部枚举类，其中定义了Java线程的六种状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="状态的转化"><a href="#状态的转化" class="headerlink" title="状态的转化"></a>状态的转化</h2><p><img src="/2021/09/24/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%8A%B6%E6%80%81/threadState.png"></p><h2 id="多线程案例"><a href="#多线程案例" class="headerlink" title="多线程案例"></a>多线程案例</h2><p>使用N个线程顺序打印数字1，2，3，4，5，6，7，8，9，每个线程只能打印一个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// i表示，要输出的数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadDemo</span><span class="params">(<span class="keyword">int</span> threadNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadNum = threadNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> self)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// 满足条件的线程才能够进行输出</span></span><br><span class="line">            <span class="keyword">if</span> (i % threadNum == self) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; === &quot;</span> + i++);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">        ThreadDemo threadDemo = <span class="keyword">new</span> ThreadDemo(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    threadDemo.run(j);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：要满足这样一个的程序让当前正在执行的线程知道自己能不能输出，并且输出的变量也应该是对所有线程可见的，在对每一个线程进行标识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程的定义与状态&quot;&gt;&lt;a href=&quot;#线程的定义与状态&quot; class=&quot;headerlink&quot; title=&quot;线程的定义与状态&quot;&gt;&lt;/a&gt;线程的定义与状态&lt;/h1&gt;&lt;h2 id=&quot;线程与进程&quot;&gt;&lt;a href=&quot;#线程与进程&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="多线程" scheme="http://feelerice.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收算法（下）</title>
    <link href="http://feelerice.github.io/2021/09/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://feelerice.github.io/2021/09/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2021-09-19T03:05:11.000Z</published>
    <updated>2021-09-19T05:41:58.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收算法（下）"><a href="#垃圾回收算法（下）" class="headerlink" title="垃圾回收算法（下）"></a>垃圾回收算法（下）</h1><h2 id="垃圾收集理论"><a href="#垃圾收集理论" class="headerlink" title="垃圾收集理论"></a>垃圾收集理论</h2><p>当前绝大多数商用虚拟机（包括HostSpot虚拟机）都采用了“<strong>分代收集</strong>”（Generational  Collection）的理论进行设计的，分代收集名为理论，实质上是一套符合绝大多数程序运行实际情况的<strong>经验法则</strong>，它建立在两个分代假说之上：</p><ol><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕死。</li><li>强分代假说（String Generational Hypothesis）：熬过多次垃圾收集过程的对象就越难消亡。</li></ol><p>这两个分代假说理论共同奠定了多款常用垃圾收集器的一致的设计原则：收集器应当将Java堆划分出不同的区域，然后根据其年龄（存放在对象头中，其最大值为二进制的1111，每进行一次垃圾回收就加一）分配到不同的区域之中存储。</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记-清除算法是最为基础的垃圾收集算法，其定义如下：</p><blockquote><p>首先标记出所有需要回收的对象，在标记完成之后，统一回收掉所有被标记的对象；也可以反过来，标记所有存活的对象，统一回收所有未被标记的对象。</p></blockquote><p>之所以说它是最基础的收集算法，是因为后续的垃圾收集算法都是在标记-清除算法的基础上改良其缺点而得到的。其缺点主要有两个：</p><ol><li>执行效率不稳定</li><li>空间碎片化问题</li></ol><p>执行效率不稳定的原因是每一次进行垃圾回收都会对对象进行标记，随着对象的增多在进行回收时所进行标记的动作也会随之增加，消耗的时间也会随之增加，导致其执行的效率随对象的增长二降低。</p><p>内存碎片化问题是因为是在标记清除对象之后，会产生大量不连续的内存碎片，这样就可能会导致在之后的对象分配时，无法找到足够的内存块给当前对象分配内存而导致提前触发下一次的GC。</p><p><img src="/2021/09/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/markSweep.png" alt="标记清除算法图例"></p><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>标记复制算法一般被称之为复制算法，为了解决标记-清除算法面对大量可回收对象时执行效率低下的问题，在1969年提出了一种称为“半区复制”（Semispace Copying）的 垃圾回收算法。</p><blockquote><p>将内存空间划分为两个半区，每次只使用其中一块，当这一块的内存使用完了之后，就将还存活的对象复制到另一块半区之上，然后再将已经使用过的半区的内存空间一次清理掉。</p></blockquote><p>如果内存中多数对象都是存活的，那么这种算法将会产生大量的内存间的复制的开销，但对于多数对象都是可回收的情况下，这种算法只需要复制较少部分的对象，而且每一次都是对整个半区进行清除回收，分配内存的时候也不再需要考虑内存碎片的情况。这样实现简单，运行高效，不过其缺点也显而易见，每次只能使用半区，空间的浪费有点太大了。</p><p><img src="/2021/09/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/copying.png" alt="标记复制算法图例"></p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记复制算法在对象存货较多的情况下会复制大量的存货对象，这样会造成资源的大量浪费，效率也会下降，并且还会浪费50%的内存。所以在老年代之中一般不会采用这种算法。</p><p>在1974年提出了一种新的算法标记-整理算法，其只是在标记-清除算法的基础之上再添加了一个将所有存活的对象移动到内存空间的一端，然后清除掉边界之外的内存。</p><p>标记整理算法和标记清除算法最主要的区别就是后者是一种非移动式的回收算法，而前者则是一个移动式的回收算法啊。</p><p><img src="/2021/09/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/markCompact.png" alt="标记整理算法图例"></p><p>如果移动对象尤其是在老年代这种每次回收都有大量对象存活的区域，移动存活的对象并且更新所有引用的这些对象的地方就会是非常繁重的事，而且这种对象的移动必须暂停用户线程在能进行（Stop The World）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收算法（下）&quot;&gt;&lt;a href=&quot;#垃圾回收算法（下）&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收算法（下）&quot;&gt;&lt;/a&gt;垃圾回收算法（下）&lt;/h1&gt;&lt;h2 id=&quot;垃圾收集理论&quot;&gt;&lt;a href=&quot;#垃圾收集理论&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="JVM" scheme="http://feelerice.github.io/tags/JVM/"/>
    
    <category term="垃圾回收" scheme="http://feelerice.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收算法（上）</title>
    <link href="http://feelerice.github.io/2021/09/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://feelerice.github.io/2021/09/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2021-09-18T05:44:33.000Z</published>
    <updated>2021-09-18T06:41:43.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收算法（上）"><a href="#垃圾回收算法（上）" class="headerlink" title="垃圾回收算法（上）"></a>垃圾回收算法（上）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>说起垃圾回收（Garbage Collection，下文简称为GC），有不少人认为这项技术是为Java语言的伴生产物，其实垃圾回收的历史比Java的历史要长的多。在1960年诞生于麻省理工大学的Lisp是第一门开始使用内存动态分配和垃圾回收技术的语言。当Lisp还在胚胎阶段的时候，其作者就考虑过垃圾回收器应该要完成的三件事：</p><ul><li>那些内存需要进行回收？</li><li>什么时候进行回收？</li><li>如何回收？</li></ul><p>在Java内存运行时区域的各部分，其中<strong>程序计数器、虚拟机栈、本地方法栈</strong>3个区域随着线程的诞生而诞生，随线程的消亡而消亡。每一个虚拟机栈帧在编译时就已经确定了大小，因此这几个区域的内存分配和回收都具有确定性，在这几个区域就不需要考虑如何回收的问题了。</p><p>然而在Java的<strong>堆内存</strong>和<strong>方法区</strong>这两个区域则有着很显著的不确定性：一个接口的不同实现类需要的内存可能会不一样，一个方法所指向的不同条件分支所需要的内存也可能不一样，只有在运行期间，我们在知道程序究竟会创建哪些对象，分配多少内存，这部分内存的分配与回收都是动态的。所以我们垃圾回收也就更多的考虑这一部分的内存。</p><h2 id="那些内存需要回收？"><a href="#那些内存需要回收？" class="headerlink" title="那些内存需要回收？"></a>那些内存需要回收？</h2><p>在Java堆之中存放着机会Java世界的所有对象实例，垃圾回收器在对这些对象进行回收的时候，有一件事是必须要确认的，那就是“对象是否死去”，死去的含义就是：不可能在被任何地方所使用的对象。下面将会介绍两种判断对象是否死去的算法：引用计数算法，可达性分析算法。</p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><blockquote><p>在对象中添加一个引用计数器，每当有一个地方引用她的时候，计数器就进行加1操作；当引用失效的时候，计数器就进行减1的操作。当计数器的值等于0的对象就是不可能在被使用的</p></blockquote><p>优点：</p><ul><li>原理简单</li><li>判断效率高</li></ul><p>但是Java绝大部分的虚拟机都不采用这种算法，这是由于当内存中的两个对象产生循环引用的时候，引用计数算法本身是无法判断的。这需要Java虚拟机重新提供一种方式用来判断对象是否存在循环引用。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>对于市面上的主流商用程序语言（Java、C#）的内存管理子系统都是采用可达性分析算法来判断对象是否存活的。</p><blockquote><p>通过程序中的“GC Root”根对象进行引用向下检索，搜索过程所走过的路径被称之为“引用链”（Reference Chain），如果对象不可以被搜索到，就证明对象不可达。</p></blockquote><p>在Java语言中，固定座位GC Root的对象包括以下几种：</p><ul><li>在虚拟机栈（栈帧中的本地变量表）中所引用的对象，譬如当前方法所用的参数，局部变量，临时变量等</li><li>在方法区中类静态属性引用的变量，譬如Java类的引用类型静态变量</li><li>子啊方法区中常量所引用的对象，譬如字符串常量池（String table）里面的引用</li><li>在本地方法栈中JNI（Native方法）引用的变量</li><li>Java虚拟机内部的引用，如基本数据类型所对应的Class对象，一些常驻的异常对象（NullPointException）等，还有系统类加载器</li><li>所有被同步锁（synchronized关键字）持有的对象</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调，本地代码缓存等。</li></ul><p><img src="/2021/09/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/access.png" alt="利用可达性分析算法判断对象是否可以回收"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收算法（上）&quot;&gt;&lt;a href=&quot;#垃圾回收算法（上）&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收算法（上）&quot;&gt;&lt;/a&gt;垃圾回收算法（上）&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="JVM" scheme="http://feelerice.github.io/tags/JVM/"/>
    
    <category term="垃圾回收" scheme="http://feelerice.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>对象的内存布局</title>
    <link href="http://feelerice.github.io/2021/09/17/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>http://feelerice.github.io/2021/09/17/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</id>
    <published>2021-09-17T14:58:26.000Z</published>
    <updated>2021-09-17T15:18:54.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java的对象内存布局"><a href="#Java的对象内存布局" class="headerlink" title="Java的对象内存布局"></a>Java的对象内存布局</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于Java程序而言，绝大部分的数据（对象）都存放在堆内存中。对象在堆内存中的存储布局可以划分为三个部分：</p><ul><li>对象头（Header）</li><li>实例数据（Instance Data）</li><li>对齐填充（Padding）</li></ul><h2 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h2><p>HotSpot虚拟机中，对象的对象头部分包括两部分内容：</p><ol><li>用于存储对象自身运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等信息。</li><li>类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定当前对象是哪个类的实例。</li></ol><p><strong>注：在数组对象中，对象头还必须有一块用于记录数组长度的数据</strong></p><h2 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h2><p>即我们在程序中定义的类中类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p><p>在HotSpot虚拟机中实例数据的存储顺序会受到一下配置的影响</p><blockquote><p>-XX:FieldAllocationStyle</p></blockquote><p>其顺序为：Double/Long、ints、shorts、chars/booleans、oops（Ordinary Object Pointers、oops）</p><p>可以看出相同宽度的字段总是被分配到一起存放，在满足这个顺序的前提下，在父类中定义的变量会被分配到子类的变量前面。</p><p>如果使用以下参数，那么子类中较窄的变量也允许插入到父类变量的空隙中。</p><blockquote><p>-XX : CompactFields</p></blockquote><h2 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h2><p>对于Java对象而言，这一部分并不是必须存在的。由于HotSpot虚拟机的内存自动管理系统要求对象起始地址都必须是8字节的整数倍，也就是说对象的大小必须时8字节的整数倍。那么对于一些不满足8字节整数倍大小的对象来说，就需要这一部分来进行对齐填充来补全。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java的对象内存布局&quot;&gt;&lt;a href=&quot;#Java的对象内存布局&quot; class=&quot;headerlink&quot; title=&quot;Java的对象内存布局&quot;&gt;&lt;/a&gt;Java的对象内存布局&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="锁" scheme="http://feelerice.github.io/tags/%E9%94%81/"/>
    
    <category term="JVM" scheme="http://feelerice.github.io/tags/JVM/"/>
    
    <category term="hotSpot" scheme="http://feelerice.github.io/tags/hotSpot/"/>
    
  </entry>
  
  <entry>
    <title>redis的持久化策略</title>
    <link href="http://feelerice.github.io/2021/09/16/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <id>http://feelerice.github.io/2021/09/16/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</id>
    <published>2021-09-16T01:33:31.000Z</published>
    <updated>2021-09-16T04:46:26.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis的持久化策略"><a href="#redis的持久化策略" class="headerlink" title="redis的持久化策略"></a>redis的持久化策略</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。</p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。</p><h3 id="save触发RDB"><a href="#save触发RDB" class="headerlink" title="save触发RDB"></a>save触发RDB</h3><p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p><h3 id="bgsave触发RDB"><a href="#bgsave触发RDB" class="headerlink" title="bgsave触发RDB"></a>bgsave触发RDB</h3><p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。</p><p>具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</p><h3 id="自动触发RDB"><a href="#自动触发RDB" class="headerlink" title="自动触发RDB"></a>自动触发RDB</h3><p>自动触发是由我们的配置文件来完成的。在<strong>redis.conf</strong>配置文件中，里面有如下配置，我们可以去设置：</p><ol><li><strong>save：</strong>这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</li></ol><p>默认如下配置：</p><blockquote><p>save 900 1 表示900 秒内如果至少有 1 个 key 的值变化，则保存<br>save 300 10表示300 秒内如果至少有 10 个 key 的值变化，则保存<br>save 60 10000表示60 秒内如果至少有 10000 个 key 的值变化，则保存</p></blockquote><p><strong>不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。</strong></p><ol start="2"><li><p><strong>stop-writes-on-bgsave-error ：</strong>默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</p></li><li><p><strong>rdbcompression ；</strong>默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</p></li><li><p><strong>rdbchecksum ：</strong>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p></li><li><p><strong>dbfilename ：</strong>设置快照的文件名，默认是 dump.rdb</p></li><li><p><strong>dir：</strong>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</p></li></ol><h2 id="RDB-的优势和劣势"><a href="#RDB-的优势和劣势" class="headerlink" title="RDB 的优势和劣势"></a>RDB 的优势和劣势</h2><ol><li>优势</li></ol><ul><li> RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li><li>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ul><ol start="2"><li><p>劣势</p><p>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p></li></ol><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF其实就是把每一次的更新操作都记录下来，以此来保证数据的持久化。</p><p><strong>文件重写原理</strong></p><p>每次的更新都需要记录下来这一次更新对的操作指令，那么随着时间的边长AOF文件的体积也会随之增加。所以为了压缩AOF的持久化文件，我们需要对压缩文件进行更新操作，也就是对持久化的Key保存最后一次的更新操作。</p><h3 id="AOF也有三种触发机制"><a href="#AOF也有三种触发机制" class="headerlink" title="AOF也有三种触发机制"></a>AOF也有三种触发机制</h3><p>（1）每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p><p>（2）每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</p><p>（3）不同no：从不同步</p><table><thead><tr><th align="center">命令</th><th align="center">always</th><th align="center">eveysec</th><th align="center">no</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">不丢失数据</td><td align="center">每秒一次fsysc</td><td align="center">不管用</td></tr><tr><td align="center">缺点</td><td align="center">IO开销大</td><td align="center">丢失1秒钟的数据</td><td align="center">不可控</td></tr></tbody></table><h2 id="AOF的优缺点"><a href="#AOF的优缺点" class="headerlink" title="AOF的优缺点"></a>AOF的优缺点</h2><p>优点</p><ul><li>日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</li><li>AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</li><li>AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</li></ul><p>缺点</p><ul><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</li><li>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</li><li>以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis的持久化策略&quot;&gt;&lt;a href=&quot;#redis的持久化策略&quot; class=&quot;headerlink&quot; title=&quot;redis的持久化策略&quot;&gt;&lt;/a&gt;redis的持久化策略&lt;/h1&gt;&lt;h2 id=&quot;RDB&quot;&gt;&lt;a href=&quot;#RDB&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="redis" scheme="http://feelerice.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis的五种基本数据类型</title>
    <link href="http://feelerice.github.io/2021/09/16/redis%E7%9A%84%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://feelerice.github.io/2021/09/16/redis%E7%9A%84%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-09-16T01:19:53.000Z</published>
    <updated>2021-09-16T01:33:36.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis的五种基本数据类型"><a href="#redis的五种基本数据类型" class="headerlink" title="redis的五种基本数据类型"></a>redis的五种基本数据类型</h1><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><blockquote><p>常用命令: set,get,decr,incr,mget 等。</p></blockquote><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><blockquote><p>常用命令: lpush,rpush,lpop,rpop,lrange等</p></blockquote><p>Hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅 仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key=JavaUser293847</span><br><span class="line">value=&#123;</span><br><span class="line">    “id”: 1,</span><br><span class="line">    “name”: “feelerice”,</span><br><span class="line">    “age”: 22,</span><br><span class="line">    “location”: “Sichuan, Chengdu”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><blockquote><p>常用命令: lpush,rpush,lpop,rpop,lrange等</p></blockquote><p>list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表， 消息列表等功能都可以用Redis的 list 结构来实现。 Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。 另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功 能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><blockquote><p>常用命令： sadd,spop,smembers,sunion 等</p></blockquote><p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。 当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在 一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。 比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常 方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinterstore key1 key2 key3 将交集存在key1内</span><br></pre></td></tr></table></figure><h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><blockquote><p>常用命令： zadd,zrange,zrem,zcard等</p></blockquote><p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。 =</p><p>举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维 度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis的五种基本数据类型&quot;&gt;&lt;a href=&quot;#redis的五种基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;redis的五种基本数据类型&quot;&gt;&lt;/a&gt;redis的五种基本数据类型&lt;/h1&gt;&lt;h2 id=&quot;string&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="redis" scheme="http://feelerice.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://feelerice.github.io/2021/09/15/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://feelerice.github.io/2021/09/15/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-09-15T09:16:31.000Z</published>
    <updated>2021-09-15T09:31:25.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p><p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p><p><img src="/2021/09/15/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/singleton.png"></p><p>单例模式设计的核心思想：</p><ul><li>私有化构造器</li><li>提供一个静态方法以获取唯一实例。</li></ul><h2 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insatnce;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典实现方式，在加载类的时候直接创建唯一实例</p><h2 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2.懒汉式"></a>2.懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在加载类文件的时候不会直接创建实例，而是等到用户需要使用的时候才会创建实例，但是<strong>线程不安全</strong></p><h2 id="3-DCL（double-check-lock）"><a href="#3-DCL（double-check-lock）" class="headerlink" title="3.DCL（double check lock）"></a>3.DCL（double check lock）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双检锁，又叫双重校验锁，综合了懒汉式和饿汉式两者的优缺点整合而成。看上面代码实现中，特点是在synchronized关键字内外都加了一层 if 条件判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。</p><h2 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4.匿名内部类"></a>4.匿名内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClassInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClassInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类的方式效果类似双检锁，但实现更简单。但这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p><h2 id="5-枚举类"><a href="#5-枚举类" class="headerlink" title="5.枚举类"></a>5.枚举类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举的方式是比较少见的一种实现方式，但是看上面的代码实现，却更简洁清晰。并且她还自动支持序列化机制，绝对防止多次实例化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://feelerice.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
